"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7123],{1184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(4041);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},9541:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"admin-guide-to-x500","title":"Administrator\'s Deep Dive","description":"What follows is a deep dive for administrators of the directory. This is an","source":"@site/docs/admin-guide-to-x500.md","sourceDirName":".","slug":"/admin-guide-to-x500","permalink":"/directory/docs/admin-guide-to-x500","draft":false,"unlisted":false,"editUrl":"https://github.com/Wildboar-Software/directory/edit/main/website/docs/admin-guide-to-x500.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"User\'s Deep Dive","permalink":"/directory/docs/user-guide-to-x500"},"next":{"title":"Why Not LDAP?","permalink":"/directory/docs/why-not-ldap"}}');var i=t(1085),r=t(1184);const a={},o="Administrator's Deep Dive",c={},l=[{value:"Naming Contexts and Request Routing",id:"naming-contexts-and-request-routing",level:2},{value:"Cross References",id:"cross-references",level:2},{value:"Operational Bindings",id:"operational-bindings",level:2},{value:"Hierarchical Operational Bindings (HOBs)",id:"hierarchical-operational-bindings-hobs",level:3},{value:"Non-Specific Hierarchical Operational Bindings (NHOBs)",id:"non-specific-hierarchical-operational-bindings-nhobs",level:3},{value:"Shadowing Operational Bindings (SOBs)",id:"shadowing-operational-bindings-sobs",level:3},{value:"Administrative Areas",id:"administrative-areas",level:2},{value:"Access Control",id:"access-control",level:2},{value:"Access Control Items: An Intuitive Understanding",id:"access-control-items-an-intuitive-understanding",level:3},{value:"Basic Access Control",id:"basic-access-control",level:3},{value:"Simplified Access Control",id:"simplified-access-control",level:3},{value:"Rule-Based Access Control",id:"rule-based-access-control",level:3},{value:"Context Assertion Defaults",id:"context-assertion-defaults",level:2},{value:"Password Administration",id:"password-administration",level:2},{value:"Service Administration",id:"service-administration",level:2},{value:"Subschema Administration",id:"subschema-administration",level:2},{value:"Integrity at Rest",id:"integrity-at-rest",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"administrators-deep-dive",children:"Administrator's Deep Dive"})}),"\n",(0,i.jsxs)(n.p,{children:["What follows is a deep dive for administrators of the directory. This is an\nattempt to be a high-level overview. Administrators seeking to fully understand\nX.500 directories should read the X.500 specifications. See\n",(0,i.jsx)(n.a,{href:"/directory/docs/specs",children:"Specifications"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"naming-contexts-and-request-routing",children:"Naming Contexts and Request Routing"}),"\n",(0,i.jsx)(n.p,{children:"Earlier, we established that the directory can be (and is likely to be, given\nits use case) partitioned across a multitude of X.500 directory servers (DSAs)."}),"\n",(0,i.jsx)(n.p,{children:'For the various DSAs to provide a seemless experience as though the user were\nonly interacting with a single server, these DSAs store not only directory\nentries, but a supercategory of "things that fall within the DIT" called\nDSA-Specific Entries (DSEs). As you can imagine, when you have a distributed\nsystem like this, each DSA is going to have its own "perspective" of what the\ndirectory looks like. For a given distinguished name referring to something in\nthe DIT, two DSAs might have something stored, but one might be a master entry\nin one DSA, and the other might be a shadow (replicated entry) in the other\nDSA. In addition to this, DSAs may store "reference DSEs" that "point" to the\nDSAs where an entry is really stored.'}),"\n",(0,i.jsxs)(n.p,{children:["Let's explore an example. Let's say the United States government runs an X.500\nDSA. It administers the ",(0,i.jsx)(n.code,{children:"c=US"})," namespace of the directory. The ",(0,i.jsx)(n.code,{children:"c=US"})," entry\nmight have some real entries beneath it, such as ",(0,i.jsx)(n.code,{children:"c=US,o=Congress"}),', but also\nsome subordinate namespaces ("context prefixes") handled by other DSAs. The\nsubstituent 50 states of the United States may themselves have DSAs. For\nexample, ',(0,i.jsx)(n.code,{children:"c=US,st=FL"})," ",(0,i.jsx)(n.em,{children:"could"})," be administered in the United States' DSA, but it\nwould be likely that Florida would want to manage its own DSA."]}),"\n",(0,i.jsxs)(n.p,{children:["Hence, the ",(0,i.jsx)(n.code,{children:"c=US"})," DSA would have a reference DSE named ",(0,i.jsx)(n.code,{children:"c=US,st=FL"})," that\npoints to the network address (IP address or hostname, protocol, and port) of\nthe DSA that administers the ",(0,i.jsx)(n.code,{children:"c=US,st=FL"})," namespace. The ",(0,i.jsx)(n.code,{children:"c=US,st=FL"})," DSA would\nhave the real entry for ",(0,i.jsx)(n.code,{children:"c=US,st=FL"})," and for ",(0,i.jsx)(n.code,{children:"c=US"}),", it would have a reference\nDSE pointing back to the DSA that administers the ",(0,i.jsx)(n.code,{children:"c=US"})," namespace. No matter\nwhere a request starts in the directory--no matter what entry is sought--the\ndirectory information tree can be navigated up and down using these reference\nDSEs to find the DSA that administers a given entry. This works kind of like\nthe ",(0,i.jsx)(n.code,{children:"NS"})," record in DNS, where a domain can delegate management of a subdomain\nto a separate name server: in that same way, DSAs can delegate subtrees\nof the DIT to other DSAs by storing reference DSEs identifying the responsible\nDSA instead of storing the entry itself."]}),"\n",(0,i.jsx)(n.p,{children:'To clarify, the directory does more than merely store these references: it is\na feature of the directory that the DSAs themselves use them. This is how\nchaining is achieved: a DSA descends its own internal DSA-specific information\ntree (called a "DSAIT") to find an entry sought by a directory user, and when\nit encounters a reference entry, it either forwards the request to the DSA\nresponsible for that namespace, or it returns a referral back to the user,\nthereby saying "you make this request."'}),"\n",(0,i.jsxs)(n.p,{children:["To help understand this, let's consider a hypothetical routing scenario: a user\nin Hamburg, Germany, wants to read an entry ",(0,i.jsx)(n.code,{children:"c=US,st=FL,cn=Jonathan Wilbur"}),'.\nThis user\'s "home DSA" is ',(0,i.jsx)(n.code,{children:"c=DE,l=Hamburg"}),": they authenticate to and send\nrequests to this server. The DSA responsible for ",(0,i.jsx)(n.code,{children:"c=DE,l=Hamburg"})," sees that not\neven the first RDN of the sought distinguished name (",(0,i.jsx)(n.code,{children:"c=US"}),") matches what the\nuser is searching for, so the request has ",(0,i.jsx)(n.em,{children:"ascend"})," the directory information\ntree until we reach ",(0,i.jsx)(n.code,{children:"c=US"}),", then it can descend. So it forwards the request to\nthe DSA that administers ",(0,i.jsx)(n.code,{children:"c=DE"}),'. This DSA is a special "top-level DSA," which\ncontains the reference DSEs for all of the other countries, so it forwards the\nrequest laterally to the DSA that administers ',(0,i.jsx)(n.code,{children:"c=US"}),". The DSA for ",(0,i.jsx)(n.code,{children:"c=US"})," sees that it has\na DSE for ",(0,i.jsx)(n.code,{children:"c=US,st=FL"}),", but it is a reference DSE--not the real entry--so the\nDSA forwards the request to the DSA that handles the ",(0,i.jsx)(n.code,{children:"c=US,st=FL"})," namespace.\nFinally, the DSA that administers ",(0,i.jsx)(n.code,{children:"c=US,st=FL"})," sees that it has the entry named\n",(0,i.jsx)(n.code,{children:"c=US,st=FL,cn=Jonathan Wilbur"}),". It produces a result, possibly signs it to\nensure end-to-end integrity, and propagates this result back to the user,\ntraversing the exact path from which this request came in reverse."]}),"\n",(0,i.jsx)(n.h2,{id:"cross-references",children:"Cross References"}),"\n",(0,i.jsxs)(n.p,{children:["Forwarding so many requests to a top-level DSA to be able to traverse laterally\nin the DIT would be extremely taxing on a very important DSA. One optimization\ndirectories can implement is cross references. These are basically cached\nreferences for other DSAs in the DIT. When you use DNS and resolve,\n",(0,i.jsx)(n.code,{children:"www.google.com"}),", your computer isn't making a request to the root nameserver\nevery single time: it caches the addresses of the servers that manage ",(0,i.jsx)(n.code,{children:"com"}),",\n",(0,i.jsx)(n.code,{children:"google.com"}),", etc. In this same way, DSAs can store pointers to namespaces they\nhave previously resolved."]}),"\n",(0,i.jsxs)(n.p,{children:["Continuing on our previous example, the DSA for ",(0,i.jsx)(n.code,{children:"c=DE,l=Hamburg"})," can request\nthat the ",(0,i.jsx)(n.code,{children:"c=US"})," DSA return cross references. The ",(0,i.jsx)(n.code,{children:"c=US"})," DSA's chained request\nresponse can then contain the routable address of the DSA that administers\n",(0,i.jsx)(n.code,{children:"c=US,st=FL"}),". The ",(0,i.jsx)(n.code,{children:"c=DE,l=Hamburg"})," can then forward requests destined for this\nnamespace directly to the responsible DSA instead of propagating it up and down\nthrough the directory."]}),"\n",(0,i.jsx)(n.p,{children:"Note that cross references, like any cached data, can become stale and contain\ninformation that is out-of-date, and trusting cross-references itself has\nsecurity implications that ought to be considered by directory administrators."}),"\n",(0,i.jsx)(n.h2,{id:"operational-bindings",children:"Operational Bindings"}),"\n",(0,i.jsx)(n.p,{children:'One thing you might be wondering is: how do reference DSEs get in the directory?\nThey could be administered manually, but the preferrable method is for two\ncorrespondent DSAs to establish what is called an "operational binding." An\noperational binding is a bilateral agreement between two DSAs to provide some\nservice.'}),"\n",(0,i.jsx)(n.p,{children:"There is a standard protocol by which a DSA proposes an operational binding to\nanother DSA: the Directory Operational Binding Management Protocol (DOP). This\nprotocol provides three operations: establish, modify, and terminate for a given\noperational binding. When establishing or modifying operational bindings,\nparameters of the proposed bilateral operation are sent. Operational bindings\nare identified by unique numbers assigned by the correspondent DSAs, and also\ninclude revision numbers for when modifications are made."}),"\n",(0,i.jsx)(n.p,{children:"In the X.500 specifications, there are three types of operational bindings\ndefined, which we will discuss."}),"\n",(0,i.jsx)(n.h3,{id:"hierarchical-operational-bindings-hobs",children:"Hierarchical Operational Bindings (HOBs)"}),"\n",(0,i.jsx)(n.p,{children:'In a Hierarchical Operational Binding (HOB), one DSA agrees to be the "superior"\nDSA and another a "subordinate." This is a simple case where a DSA delegates a\nsubtree of the DIT that it would otherwise control to another DSA; concretely,\nthat means that it forwards requests targeting entries that fall within that\nnamespace to the subordinate DSA. The result of an HOB in the DIT is a\n"subordinate reference" DSE in the superior DSA that points to the subordinate\nDSA, and a "superior reference" DSE in the subordinate DSA that points to the\nsuperior DSA.'}),"\n",(0,i.jsx)(n.h3,{id:"non-specific-hierarchical-operational-bindings-nhobs",children:"Non-Specific Hierarchical Operational Bindings (NHOBs)"}),"\n",(0,i.jsx)(n.p,{children:'A Non-Specific Hierarchical Operational Binding (NHOB) is like the Hierarchical\nOperational Binding (HOB), but with a twist: multiple DSAs compete for the\nnamespace subordinate to an entry. When I say "compete," it is not to insinuate\nthat there is an adversarial relationship, but merely that names within the\nnamespace are allocated on a first-come-first-served basis to the involved\nsubordinate DSAs.'}),"\n",(0,i.jsxs)(n.p,{children:["In an NHOB, instead of a single subordinate reference DSE that points to a DSA\n(or cluster of them) that ",(0,i.jsx)(n.em,{children:"definitely"})," has the entry for the next RDN to be\nresolved, it uses a ",(0,i.jsx)(n.em,{children:"Non-Specific Subordinate Reference"})," (NSSR) which contains\na list of subordinate DSAs that ",(0,i.jsx)(n.em,{children:"might"})," have it. When an entry subordinate to\nthe reference is sought, all of the subordinate DSAs are queried until one\n(or none) returns a result."]}),"\n",(0,i.jsx)(n.p,{children:"DSAs in an NSSR do coordinate to avoid naming conflicts: when they create a new\nentry, the subordinate DSA is expected to attempt a read operation to all of\nthem to check if the entry exists. This is imperfect: there could be a race\ncondition in which duplicates are introduced, so this requires careful\ncoordination and doesn't scale well."}),"\n",(0,i.jsx)(n.p,{children:"It is not obvious to me why NHOBs would even be desirable: it is going to be\nless performant to have indeterminate routing information. The only benefit I\ncan see is less managerial overhead from having to manage a single operational\nbinding per subordinate naming context as is the case with HOBs. Either way,\nNHOBs are there for you to use."}),"\n",(0,i.jsx)(n.h3,{id:"shadowing-operational-bindings-sobs",children:"Shadowing Operational Bindings (SOBs)"}),"\n",(0,i.jsx)(n.p,{children:"We have already discussed shadowing in the User's Deep Dive, so it is presumed\nthat you understand what shadowing is: basically, the provisioning of read-only\nreplicas of directory information for better throughput and availability."}),"\n",(0,i.jsx)(n.p,{children:"Shadowing is established by a Shadowing Operational Binding (SOB). When\nestablished or modified, this operational binding's parameters include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["What directory information is to be replicated, including:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Which entries"}),"\n",(0,i.jsx)(n.li,{children:"Which attributes"}),"\n",(0,i.jsx)(n.li,{children:"Which values"}),"\n",(0,i.jsx)(n.li,{children:"Which contexts"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["How often the replication is to take place, which can be:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"At regular intervals, or"}),"\n",(0,i.jsx)(n.li,{children:"Whenever the information changes"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Who is to initiate the replication operations: the shadow DSA or master DSA"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'SOBs may be "pull" or "push": it may be expected that the shadow supplier\nperiodically--or upon modifications--push changes to its consumers, or it may\nbe expected that the shadow consumers periodically "poll" the shadow supplier\nfor updates.'}),"\n",(0,i.jsx)(n.p,{children:"Shadow updates are coordinated by specific shadowing operations, which are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"coordinateShadowUpdate"}),': used by a shadow supplier in the "push" model to\nannounce a forthcoming shadow update, to get prior approval before sending it,\nand ensuring that the DSAs are in agreement as to when the last shadow update\noccurred (this matters for ensuring incremental updates are complete).']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"requestShadowUpdate"}),': used by a shadow consumer in the "pull" model to\nrequest an update.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"updateShadow"}),": is the operation that contains the actual shadowed data."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"updateShadow"}),' operation may contain the entirety of all data to be updated,\ncalled a "total refresh," or just whatever changed since the last update, called\nan "incremental refresh." Alternative update methods could be defined. The\nchoice of method used could be requested by a shadow supplier when requesting a\nshadow update.']}),"\n",(0,i.jsx)(n.h2,{id:"administrative-areas",children:"Administrative Areas"}),"\n",(0,i.jsx)(n.p,{children:'Just as the directory can be physically partitioned among multiple DSAs, the\ndirectory information tree can be partitioned in into "administrative areas" in\nwhich different access control rules, services, assumptions,\ncollective attributes, etc. apply.'}),"\n",(0,i.jsxs)(n.p,{children:["An administrative area is created merely by adding an ",(0,i.jsx)(n.code,{children:"administrativeRole"}),'\nattribute to an entry in the DIT: this makes this entry an "administrative\npoint."']}),"\n",(0,i.jsxs)(n.p,{children:['Other than this attribute, (almost) all other configuration for administrative\nareas falls within special entries immediately subordinate to the administrative\npoint, called "subentries." Subentries are entries of object class ',(0,i.jsx)(n.code,{children:"subentry"}),".\nSubentries MUST contain a name and a specification of the subtree of the\nadministrative area to which their effects apply: other than this, auxiliary\nobject classes are used to add more attributes depending on what administrative\narea type it configures."]}),"\n",(0,i.jsx)(n.p,{children:"The directory specifications define the following administrative area types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Access Control Administrative Areas: where access controls are defined"}),"\n",(0,i.jsx)(n.li,{children:"Subschema Administrative Areas: where recognized or applicable schema\n(e.g. attributes, object classes, etc.) may vary."}),"\n",(0,i.jsx)(n.li,{children:"Collective Attributes Administrative Areas: where collective attributes are\napplied to entries"}),"\n",(0,i.jsx)(n.li,{children:"Context Default Administrative Areas: where default context assertions are\napplied to requests if none are supplied by the user."}),"\n",(0,i.jsx)(n.li,{children:'Service Administrative Areas: where "service rules" are applied to restrict\nwhat searches may be performed.'}),"\n",(0,i.jsx)(n.li,{children:"Password Administrative Areas: where the rules for passwords (such as\nlength, complexity, alphabets, etc.) are applied."}),"\n",(0,i.jsx)(n.li,{children:'Autonomous Areas: where all superior administrative areas are effectively\nmarked as "overridden" completely.'}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Administrative areas may fall within each other: in other words, ",(0,i.jsx)(n.code,{children:"c=US"})," may be\na password administrative area, and ",(0,i.jsx)(n.code,{children:"c=US,st=FL"})," may be one as well. There is\nno conflict in this case: when passwords are managed in ",(0,i.jsx)(n.code,{children:"c=US,st=FL"})," the\npassword administrative area defined there overrides the one defined in ",(0,i.jsx)(n.code,{children:"c=US"}),".\nAs stated earlier, autonomous administrative areas entirely reset all\nsuperior administrative areas."]}),"\n",(0,i.jsxs)(n.p,{children:['In some cases, namely collective attribute administrative areas and access\ncontrol administrative areas are further partitioned into "specific areas" and\n"inner areas." Specific areas reset all superior administration of like kind:\nin other words, an access control specific area completely removes and overrides\nall access control rules defined in superior access control administrative\nareas. Inner areas, on the other hand, are ',(0,i.jsx)(n.em,{children:"additive"}),". For example, Access\nControl Inner Areas (ACIAs) may introduce more access control rules that must be\nevaluated without resetting the rules applied from superior Access Control\nSpecific Areas (ACSAs)."]}),"\n",(0,i.jsx)(n.p,{children:"These administrative areas are independent of the physical partitioning by\nnaming contexts: an administrative area may span across multiple DSAs, or there\ncan be multiple administrative areas within a single DSA."}),"\n",(0,i.jsx)(n.h2,{id:"access-control",children:"Access Control"}),"\n",(0,i.jsxs)(n.p,{children:["X.500 directories are flexible in what access control schemes they can use.\nA special attribute, ",(0,i.jsx)(n.code,{children:"accessControlScheme"}),", which is a single-valued attribute\ncontaining an object identifier, is placed in the Access Control Specific\nPoint (ACSP) (which is the administrative point for an Access Control Specific\nArea (ACSA)). This identifier determines what access control scheme is used for\nthat ACSA. Currently, the X.500 specifications define five access control\nschemes, which are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"basicAccessControlScheme"}),": Uses Access Control Items (ACIs) stored in\nentries, subentries, and administrative points"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"simplifiedAccessControlScheme"}),": Like ",(0,i.jsx)(n.code,{children:"basicAccessControlScheme"}),", but uses\nonly the access control rules in administrative points and subentries."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rule-based-access-control"}),": Uses security clearances and labels on data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rule-and-basic-access-control"}),": Combines ",(0,i.jsx)(n.code,{children:"rule-based-access-control"})," and\n",(0,i.jsx)(n.code,{children:"basicAccessControlScheme"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rule-and-simple-access-control"}),": Combines ",(0,i.jsx)(n.code,{children:"rule-based-access-control"})," and\n",(0,i.jsx)(n.code,{children:"simplifiedAccessControlScheme"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"access-control-items-an-intuitive-understanding",children:"Access Control Items: An Intuitive Understanding"}),"\n",(0,i.jsx)(n.p,{children:'If you think about how access control decisions are said aloud in natural\nlanguage, such as "forbid janitors from reading database credentials" or\n"allow administrator to change password for all employees," you\'ll notice that\naccess control rules across any application can be broken down as such:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" allow  administrator to change password for all employees\n -----  -------------    ---------------------------------\n Action   Subject                   Operation\n"})}),"\n",(0,i.jsx)(n.p,{children:'In some cases, the action is implicit: some access control schemes allow or\ndeny by default, and access control rules can only be used to restrict or grant\naccess beyond this default state. In other cases, other actions may be defined,\nsuch as "audit," in which the protected access is logged, but otherwise allowed.'}),"\n",(0,i.jsx)(n.p,{children:"Subjects are arguably a logical necessity for an access control rule. If there\naren't multiple users of something, whose access is being controlled and why?"}),"\n",(0,i.jsx)(n.p,{children:'Operations are a logical necessity as well, even if the operation is an implicit\n"everything" or "nothing." Sometimes operations are defined in terms of the\nthing being acted upon (the "object"), such that access control rules take the\nform of a "subject-verb-predicate" form. In the example above, the "object"\nwould be "all employees."'}),"\n",(0,i.jsx)(n.p,{children:"All of this was a preface to introduce the Access Control Item (ACI): the unit\nof access control configuration under Basic Access Control (BAC) and\nSimplified Access Control (SAC). It follows a subject-verb-object format, but\nwith a few other parameters. In summary, an ACI contains:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The name of the rule: ACIs are named with human-readable strings"}),"\n",(0,i.jsx)(n.li,{children:"The precedence: an integer identifying the precedence an ACI has"}),"\n",(0,i.jsx)(n.li,{children:"The authentication level: how sure we are that the user authenticated is really that user"}),"\n",(0,i.jsx)(n.li,{children:'The user: the "subject" using the terminology established above.'}),"\n",(0,i.jsx)(n.li,{children:'The item: the "object" using the terminology established above.'}),"\n",(0,i.jsx)(n.li,{children:"The operation"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There is a twist that makes ACIs difficult for the newcomer to understand, and\nfor that reason, let me start by establishing what the problem is. In access\ncontrol configuration, it is likely that patterns will emerge, if not intended.\nIn an extremely secure facility that protects the break rooms and bathrooms by\nbadge entry, lots of employees may be granted, and as such, the access control\nrules might look like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"allow:alice   :ingress:break_room\nallow:bob     :ingress:break_room\nallow:charles :ingress:break_room\nallow:desmond :ingress:break_room\nallow:emerson :ingress:break_room\nallow:alice   :ingress:bathroom\nallow:bob     :ingress:bathroom\nallow:charles :ingress:bathroom\nallow:desmond :ingress:bathroom\nallow:emerson :ingress:bathroom\n"})}),"\n",(0,i.jsx)(n.p,{children:'Depending on the situation, it might be the case that you can simplify the rules\nby putting all of these employees in a security group, then grant the security\ngroup access such access, or maybe you could put all objects in an "object\ngroup" and grant access to that. When you do this, you effectively outsource\nthe rules to some data outside of the rule itself: somewhere, some system\ncontains a list of people who are members of the security group, or a list of\nobjects that are substituents of the "object group."'}),"\n",(0,i.jsx)(n.p,{children:'This outsourcing, while unavoidable in some cases, is undesirable on some level:\nin real-world systems, it often requires more computational load or latency to\nperform a lookup of a group of people or objects. It also makes the rules less\ntransparent: what information can we glean if the rule is defined as\n"allow database readers to read the database"?'}),"\n",(0,i.jsxs)(n.p,{children:["There is an alternative: because there are patterns that tend to emerge from\nthese rules, we can ",(0,i.jsx)(n.em,{children:"compress"})," them, like so:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"allow:break_room:ingress:alice,bob,charles,desmond,emerson\nallow:bathroom:ingress:alice,bob,charles,desmond,emerson\n"})}),"\n",(0,i.jsx)(n.p,{children:'In the above example, we effectively "compressed" the objects column.\nAlternatively, we could "compress" the users column, though this is less\neffective at reducing the size of the rules:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"allow:alice   :ingress:break_room,bathroom\nallow:bob     :ingress:break_room,bathroom\nallow:charles :ingress:break_room,bathroom\nallow:desmond :ingress:break_room,bathroom\nallow:emerson :ingress:break_room,bathroom\n"})}),"\n",(0,i.jsx)(n.p,{children:'The point is that, usually, either subjects or objects in access control rules\ncan be "compressed" and hence, ACIs in the directory are defined in terms of\n"item first" or "user first" variants. Now having the intuition we have about\naccess control rules, looking at the ASN.1 definition of an ACI will make much\nmore sense:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-asn1",children:"ACIItem ::= SEQUENCE {\n  identificationTag    UnboundedDirectoryString,\n  precedence           Precedence,\n  authenticationLevel  AuthenticationLevel,\n  itemOrUserFirst      CHOICE {\n    itemFirst       [0]  SEQUENCE {\n      protectedItems       ProtectedItems,\n      itemPermissions      SET OF ItemPermission,\n      ...},\n    userFirst       [1]  SEQUENCE {\n      userClasses          UserClasses,\n      userPermissions      SET OF UserPermission,\n      ...},\n    ...},\n  ... }\n\nItemPermission ::= SEQUENCE {\n  precedence        Precedence OPTIONAL, -- defaults to precedence in ACIItem\n  userClasses       UserClasses,\n  grantsAndDenials  GrantsAndDenials,\n  ... }\n\nUserPermission ::= SEQUENCE {\n  precedence        Precedence OPTIONAL, -- defaults to precedence in ACIItem\n  protectedItems    ProtectedItems,\n  grantsAndDenials  GrantsAndDenials,\n  ... }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You will see that any alternative you choose in ",(0,i.jsx)(n.code,{children:"itemOrUserFirst"})," has all of\n",(0,i.jsx)(n.code,{children:"UserClasses"})," (subject), ",(0,i.jsx)(n.code,{children:"GrantsAndDenials"})," (verb), ",(0,i.jsx)(n.code,{children:"ProtectedItems"}),' (object).\nIn fact, the ITU-T Recommendation X.501, which defines the access control\nschemes that use ACI, even instructs implementations to effectively "decompress"\nthese ACIs into "tuples" internally before processing.']}),"\n",(0,i.jsxs)(n.p,{children:["With this intuitive understanding, let's now get into the details of an ACI,\nstarting with the user classes. There are five user classes defined by the X.500\nspecifications, which I will not explain, since they mean exactly what they\nsound like they mean: ",(0,i.jsx)(n.code,{children:"allUsers"}),", ",(0,i.jsx)(n.code,{children:"thisEntry"}),", ",(0,i.jsx)(n.code,{children:"name"}),", ",(0,i.jsx)(n.code,{children:"userGroup"}),", ",(0,i.jsx)(n.code,{children:"subtree"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Protected items can be entries, all user attributes, attribute types, attribute\nvalues, and context values, as you might expect, but the directory also supports\ncontrolling the number of values or the number of subordinate entries. Directory\nadministrators can even define protected items in terms of object classes,\nfilters that restrict the ranges of values"}),"\n",(0,i.jsxs)(n.p,{children:["There is a special ",(0,i.jsx)(n.code,{children:"selfValue"})," protected item type, which means values that are\ndistinguished names that represent the currently logged in user. The ",(0,i.jsx)(n.code,{children:"selfValue"}),"\nis useful for scenarios where you might want a user to be able to read values\nthat pertain to them in other entries: for example, seeing that they are a\nmember of a user group in the directory by granting them ",(0,i.jsx)(n.code,{children:"selfValue"})," access to\n",(0,i.jsx)(n.code,{children:"member"})," instead of giving them full access to read all values of ",(0,i.jsx)(n.code,{children:"member"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Finally, the grants and denials are simple bits defined per verb, which are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"add"}),": Add something, such as an entry or attribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"discloseOnError"}),": Disclose the existence of something hidden if there is an\nerror pertaining to it"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"read"}),": Read something, such as an entry or attribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"remove"}),": Remove something, such as an entry or attribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"browse"}),": Access an entry without providing the name explicitly"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"export"}),": Move an entry out of its current location"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"import"}),": Move an entry into this location"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"modify"}),": Modify something, such as an entry or attribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rename"}),": Rename an entry"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"returnDN"}),": Disclose the distinguished name of an entry"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"compare"}),": Compare values, perhaps against an assertion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"filterMatch"}),": Match values in a filter"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"invoke"}),": Attribute type-specific meaning"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["By default, directories try to avoid disclosing information not needed to be\nknown by users, even if indirectly via errors. For example, if I am not allowed\nto know the entries that fall beneath ",(0,i.jsx)(n.code,{children:"c=US,l=Military Base"}),", but I attempt to\ncreate ",(0,i.jsx)(n.code,{children:"c=US,l=Military Base,cn=Nuclear Missile #01"}),' and the directory responds\nwith an "entry already exists" error, it inadvertently disclosed the existence\nof an entry I wasn\'t allowed to know about. Hence, ACIs define the\n',(0,i.jsx)(n.code,{children:"discloseOnError"})," permission. If ",(0,i.jsx)(n.code,{children:"discloseOnError"}),' is not granted, directories\nare expected to return errors that portend the non-existence of a protected\nitem, such as "no such object" or "no such attribute or value" instead.']}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"invoke"})," permission is used in service administration, which we will discuss\nlater."]}),"\n",(0,i.jsx)(n.p,{children:'For each of the above permissions, a grant or a deny bit may be set, but both\nmay be unset, which means "I don\'t have an opinion on this," thereby deferring\nto other ACIs to grant or deny for that particular subject-verb-object tuple.'}),"\n",(0,i.jsx)(n.h3,{id:"basic-access-control",children:"Basic Access Control"}),"\n",(0,i.jsx)(n.p,{children:"Basic Access Control (BAC) is a scheme that users ACIs distributed throughout\nthree different operational attributes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"prescriptiveACI"}),": which apply ACIs broadly to entries in the ACSA or ACIA\nfrom subentries using their subtree specifications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"entryACI"}),': which apply "one-off" ACI to the entry in which this attribute exists']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"subentryACI"}),": live in the administrative point and apply ACI to subentries"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'Basic Access Control denies by default: in other words, if a user does not\nexplicitly have permission to do something in an ACI, they will be denied it.\nIn the interest of security, there is no way to grant access to "all operational\nattributes" even though there is for "all user attribute" with an ACI: access to\neach operational attribute has to be granted individually.'}),"\n",(0,i.jsx)(n.h3,{id:"simplified-access-control",children:"Simplified Access Control"}),"\n",(0,i.jsxs)(n.p,{children:["Simplified Access Control (SAC) is the same as Basic Access Control (BAC),\nexcept that it uses neither ",(0,i.jsx)(n.code,{children:"entryACI"})," nor Access Control Inner Areas (ACIAs)."]}),"\n",(0,i.jsx)(n.h3,{id:"rule-based-access-control",children:"Rule-Based Access Control"}),"\n",(0,i.jsxs)(n.p,{children:["Rule-Based Access Control (RBAC) is not to be confused with the much more common\nterm Role-Based Access Control. RBAC is an authentication scheme defined in\nwhich attribute values in the directory can be labeled with a special context,\n",(0,i.jsx)(n.code,{children:"attributeValueSecurityLabelContext"}),', that defines what security classification,\nsuch as "top secret" or "classified," security categories, and privacy marks\napplies to that value. Access is granted based on what clearances a user has\nbased on what values are present in the ',(0,i.jsx)(n.code,{children:"clearance"})," attribute."]}),"\n",(0,i.jsx)(n.p,{children:"Both clearances and security labels are associated with a security policy via\nan object identifier. Both clearances and security labels contain security\nclassifications: security labels contain only one defining the classification\nof the object, and clearances can contain multiple (to be explained soon)."}),"\n",(0,i.jsx)(n.p,{children:'A privacy mark may appear in a security label, which is a textual label. Its\nintended use case is something like the "NOFORN" or "CUI" as it is used in the\nUnited States.'}),"\n",(0,i.jsx)(n.p,{children:"Security categories provide further restriction within the context of a\nsecurity classification or privacy mark. It's not clear to me how they differ\nin purpose from a privacy mark, if at all."}),"\n",(0,i.jsxs)(n.p,{children:["Security policy dictates how clearances and security labels are used to grant\nor deny access. An example security policy might be the\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Bell%E2%80%93LaPadula_model",children:"Bell\u2013LaPadula (BLP) model"}),".\nIn the BLP model, subjects do not automatically have access to things of a\nless sensitive classification, hence the possibility of multiple classification\nlevels in a clearance."]}),"\n",(0,i.jsx)(n.p,{children:"The integrity of security labels is ensured by digitally signing them."}),"\n",(0,i.jsx)(n.p,{children:"Rule-Based Access Control can be combined with Basic Access Control or\nSimplified Access Control, requiring access to be granted under both schemes\nfor a given operation."}),"\n",(0,i.jsx)(n.h2,{id:"context-assertion-defaults",children:"Context Assertion Defaults"}),"\n",(0,i.jsxs)(n.p,{children:["Through the use of language contexts, the directory allows us to annotate values\nwith what language they represent. It is likely that, in a real, world-scale\ndeployment of the directory, certain attributes like ",(0,i.jsx)(n.code,{children:"description"})," might be\npresent in an entry multiple times using translations across multiple languages."]}),"\n",(0,i.jsxs)(n.p,{children:["However, for data that is expected to be of regional interest, the directory has\na way of defining default context assertions so that not all description values\nare returned every time a user performs a directory operation without the\nappropriate language context assertions. Instead, an administrative area that\ncovers an exclusively English-speaking region can define ",(0,i.jsx)(n.code,{children:"en"})," as the default\nlanguage context, and therfore, directory operations in that administrative area\nwill only return English descriptions by default."]}),"\n",(0,i.jsx)(n.p,{children:"This is only an example of a broader concept: the directory can supply default\ncontext assertions via Context Default Administrative Areas (CDAAs). Context\ndefaults can be defined for any user attribute and can use langage contexts or\nany other context type."}),"\n",(0,i.jsx)(n.h2,{id:"password-administration",children:"Password Administration"}),"\n",(0,i.jsx)(n.p,{children:"Password administrative areas allow directory administrators to define password\npolicy for an administrative area. Password policy includes things like:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Requirements on password complexity, characters, words, etc."}),"\n",(0,i.jsx)(n.li,{children:"Max failed password attempts before lockout"}),"\n",(0,i.jsx)(n.li,{children:"Lockout duration"}),"\n",(0,i.jsx)(n.li,{children:"Password history retention rules"}),"\n",(0,i.jsx)(n.li,{children:"Password encryption / hashing algorithms"}),"\n",(0,i.jsxs)(n.li,{children:["Whether passwords can be changed via ",(0,i.jsx)(n.code,{children:"modifyEntry"}),", ",(0,i.jsx)(n.code,{children:"changePassword"})," or both\noperations"]}),"\n",(0,i.jsx)(n.li,{children:"How many grace logins a user gets after his password expires"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"service-administration",children:"Service Administration"}),"\n",(0,i.jsx)(n.p,{children:'"Service administration" refers to the administration of search services in the\nX.500 directory via "search rules." By default, users may perform any search\nthey want, subject to access controls. Search rules allow directory\nadministrators to constraint the searches a user can perform.'}),"\n",(0,i.jsx)(n.p,{children:"Search rules are identified by a combination of an object identifier that\nidentifiers the Directory Management Domain (DMD), and an integer that is unique\nwithin that domain."}),"\n",(0,i.jsxs)(n.p,{children:['An object identifier also defines the "service type," the meaning of which is\nunclear to me. The specifications give no examples. However, ',(0,i.jsx)(n.code,{children:"serviceType"})," can\nbe supplied in the DAP service controls to select the applicable search rules."]}),"\n",(0,i.jsx)(n.p,{children:"A user class is a group of users identified by an integer that is unique within\nthe DMD. It's meaning is dependent on the DMD. This too can be supplied in the\nservice controls."}),"\n",(0,i.jsx)(n.p,{children:"Service administrators can restrict what attribute types can be used in filters,\nwhat attributes can be returned, what service controls are on by default,\nmandatory, how compound entries are searched and returned, what relaxations and\ntightenings are applied, how many entries can be returned, and whether the\nsearch can be performed only on the base object, at one level, or for the entire\nsubtree."}),"\n",(0,i.jsx)(n.h2,{id:"subschema-administration",children:"Subschema Administration"}),"\n",(0,i.jsx)(n.p,{children:'A Subschema Administrative Area is where directory administrators define what\nX.500 directory schema is applicable for that area. This includes things that\nare universally-defined, such as attributes, object classes, name forms,\nmatching rules, and context types, but may also contain things that are specific\nto that administrative area, such as DIT structure rules, content rules, context\nuse rules, matching rule usages, and which attributes are considered "friends."'}),"\n",(0,i.jsx)(n.h2,{id:"integrity-at-rest",children:"Integrity at Rest"}),"\n",(0,i.jsxs)(n.p,{children:["The directory also supports integrity at rest, although it is not required to do\nanything with it, such as verifying it prior to storing such protected data. An\n",(0,i.jsx)(n.code,{children:"attributeValueIntegrityInfoContext"})," context can be used to annotate attribute\nvalues with cryptographic signatures proving that they were not tampered with\nand are authentic in their origination."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"attributeIntegrityInfo"})," attribute\ncan be used to sign all (or a selection of) the attributes in an entry, all at\nonce. Note that the entire signature would have to be re-calculated if any of\nthe involved attributes change. This attribute can be used in any entry by\ngiving the entry the ",(0,i.jsx)(n.code,{children:"integrityInfo"})," object class."]}),"\n",(0,i.jsx)(n.p,{children:'It is my belief that this integrity mechanism is vulnerable to a sort of\n"replay-like" exploit: since nothing in the context value or signature binds\nthe value to the entry, these values could just be copied to other entries with\ntheir signatures intact. I will report this to the ITU Study Group 17, but until\nthis is resolved, beware relying on them.'})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);