"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1831],{43:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"authentication","title":"Authentication","description":"Meerkat DSA supports simple authentication (meaning authentication with a","source":"@site/docs/authentication.md","sourceDirName":".","slug":"/authentication","permalink":"/directory/docs/authentication","draft":false,"unlisted":false,"editUrl":"https://github.com/Wildboar-Software/directory/edit/main/website/docs/authentication.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Authorization","permalink":"/directory/docs/authorization"},"next":{"title":"Logging and Monitoring","permalink":"/directory/docs/logging-monitoring"}}');var i=n(1085),s=n(1184);const a={},o="Authentication",d={},c=[{value:"Anonymous Authentication",id:"anonymous-authentication",level:2},{value:"How Meerkat DSA Handles Passwords",id:"how-meerkat-dsa-handles-passwords",level:2},{value:"Simple Protected Passwords",id:"simple-protected-passwords",level:2},{value:"How to Set or Change Passwords",id:"how-to-set-or-change-passwords",level:2},{value:"Password Policy",id:"password-policy",level:2},{value:"Password Dictionaries",id:"password-dictionaries",level:3},{value:"Password Lockouts",id:"password-lockouts",level:3},{value:"Strong Authentication",id:"strong-authentication",level:2},{value:"SPKM Authentication",id:"spkm-authentication",level:2},{value:"External Authentication",id:"external-authentication",level:2},{value:"TLS Client Certificate Authentication",id:"tls-client-certificate-authentication",level:3},{value:"Custom External Authentication Procedures",id:"custom-external-authentication-procedures",level:3},{value:"Architectural Details",id:"architectural-details",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"authentication",children:"Authentication"})}),"\n",(0,i.jsx)(t.p,{children:"Meerkat DSA supports simple authentication (meaning authentication with a\r\npassword) and strong authentication (meaning authentication with digital signatures)\r\nin DAP, DSP, and DOP. LDAP only supports simple authentication."}),"\n",(0,i.jsx)(t.h2,{id:"anonymous-authentication",children:"Anonymous Authentication"}),"\n",(0,i.jsxs)(t.p,{children:["Users of Meerkat DSA may bind anonymously by supplying no password. If this is\r\nused, authentication will always succeed, even if the bound distinguished name\r\ndoes not correspond to any real entry present and even if the entry ",(0,i.jsx)(t.em,{children:"does"})," exist\r\nand has a password. This behavior is to avoid information disclosure."]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:'If Meerkat DSA did not do this, it would be possible for a nefarious\r\nactor to enumerate the entries in a DSA, despite access controls, by guessing\r\ndistinguished names in the bind operation and seeing which attempts come back\r\nwith errors saying "entry does not exist" and which come back with "invalid\r\npassword." This is the same reason that websites with logins must give you the\r\nsame error message, regardless of whether you got the username or password\r\nwrong.'})}),"\n",(0,i.jsx)(t.p,{children:"When users are bound anonymously, they may perform operations against Meerkat\r\nDSA. It is the responsibility of administrators to configure access controls to\r\nprevent anonymous users from doing things they should not be able to do."}),"\n",(0,i.jsx)(t.p,{children:"Currently, anonymous usage can only be prevented by access control, but a future\r\nfeature will enable administrators to reject all anonymous traffic."}),"\n",(0,i.jsx)(t.h2,{id:"how-meerkat-dsa-handles-passwords",children:"How Meerkat DSA Handles Passwords"}),"\n",(0,i.jsxs)(t.p,{children:["In the X.500 specifications, there is no specified attribute that is expected to\r\nserve as the authoritative source of the password for an entry. Each DSA may\r\nchoose to use a different attribute type to store password information; in fact,\r\npasswords might not even be stored in entries at all! This is why the\r\n",(0,i.jsx)(t.code,{children:"administerPassword"})," and ",(0,i.jsx)(t.code,{children:"changePassword"})," operations were introduced to the\r\nDirectory Access Protocol (DAP)."]}),"\n",(0,i.jsxs)(t.p,{children:["In Meerkat DSA, both the ",(0,i.jsx)(t.code,{children:"userPassword"})," attribute (specified in\r\n",(0,i.jsx)(t.a,{href:"https://www.itu.int/rec/T-REC-X.509/en",children:"ITU Recommendation X.509"}),") and the\r\n",(0,i.jsx)(t.code,{children:"userPwd"})," attribute (specified in\r\n",(0,i.jsx)(t.a,{href:"https://www.itu.int/rec/T-REC-X.520/en",children:"ITU Recommendation X.520"}),") are used.\r\nHowever, regardless of any access controls, whenever these values are read, they\r\nreturn empty strings. This is because passwords are extremely sensitive, and\r\nlet's face it: people re-use passwords between services. To prevent\r\nadministrators from misconfiguring Meerkat DSA and leaking all of their users'\r\npasswords, the passwords are simply never returned, even if queried directly,\r\nand even if access controls permit it. An empty string is returned as the value\r\nso that directory users can at least know ",(0,i.jsx)(t.em,{children:"if"})," an entry has a password. In other\r\nwords, passwords are ",(0,i.jsx)(t.em,{children:"write-only"})," in Meerkat DSA. This also applies to the\r\nencrypted variants of passwords: they are never returned so that they can never\r\nbe used for\r\n",(0,i.jsx)(t.a,{href:"https://csrc.nist.gov/glossary/term/offline_attack",children:"offline password cracking"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The password is stored in the database. If password is supplied using cleartext,\r\nit will be salted and hashed using the Scrypt algorithm and stored in the\r\ndatabase. If the password is already encrypted / hashed, it will be stored using\r\nthe algorithm that was used to encrypt it."}),"\n",(0,i.jsx)(t.h2,{id:"simple-protected-passwords",children:"Simple Protected Passwords"}),"\n",(0,i.jsxs)(t.p,{children:["Simple authentication allows users to supply a ",(0,i.jsx)(t.code,{children:"protected"})," password. Unlike the\r\n",(0,i.jsx)(t.code,{children:"unprotected"})," and ",(0,i.jsx)(t.code,{children:"userPwd"})," variants of the simple credentials password, this\r\nvariation can be protected against\r\n",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Replay_attack",children:"replay attacks"}),", and it provides\r\na form of eavesdropping-mitigating encryption, even when TLS is not used to\r\nsecure the connection."]}),"\n",(0,i.jsxs)(t.p,{children:["There is no specified algorithm for producing a ",(0,i.jsx)(t.code,{children:"protected"})," password, although\r\n",(0,i.jsx)(t.a,{href:"https://www.itu.int/rec/T-REC-X.511/en",children:"ITU Recommendation X.511 (2019)"}),",\r\nAnnex E, provides a suggested algorith. Meerkat DSA deviates from this\r\nalgorithm slightly for security reasons. The entirety of the procedures used by\r\nMeerkat DSA are documented ",(0,i.jsx)(t.a,{href:"/directory/docs/deviations-nuances#protected-passwords",children:"here"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"In short, to produce a protected password, a client must produce a DER-encoded\r\nvalue of an ASN.1 value having the following type:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-asn1",children:'Meerkats-Actual-Hashable1 ::= SEQUENCE {\r\n    name        DistinguishedName,\r\n    time1       GeneralizedTime,\r\n    random1     BIT STRING OPTIONAL,\r\n    password    encrypted < UserPwd -- This is an ASN.1 "selection type." -- }\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In the above type, ",(0,i.jsx)(t.code,{children:"name"})," is the distinguished name to which the user is\r\nattempting to bind, ",(0,i.jsx)(t.code,{children:"time1"})," is a time a few seconds into the future, ",(0,i.jsx)(t.code,{children:"random1"}),"\r\nis a sequence of randomly-generated bits of any length (preferrably at least 64\r\nbits), and ",(0,i.jsx)(t.code,{children:"password"})," is the ",(0,i.jsx)(t.code,{children:"UserPwd"})," construction of the user's password,\r\nwhich ",(0,i.jsx)(t.em,{children:"must"})," use the ",(0,i.jsx)(t.code,{children:"encrypted"})," alternative, and"]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsx)(t.p,{children:"It is strongly advised to use protected passwords whenever simple authentication\r\nis used, since they are immune to replay attacks."})}),"\n",(0,i.jsx)(t.h2,{id:"how-to-set-or-change-passwords",children:"How to Set or Change Passwords"}),"\n",(0,i.jsx)(t.p,{children:"You may set or modify a password for an entry in four ways:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["At creation time, by including password attributes in the ",(0,i.jsx)(t.code,{children:"addEntry"})," operation."]}),"\n",(0,i.jsxs)(t.li,{children:["By modifying the entry via the ",(0,i.jsx)(t.code,{children:"modifyEntry"})," operation.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If this is performed within a password administrative area, this requires\r\nthe ",(0,i.jsx)(t.code,{children:"pwdModifyEntryAllowed"})," operational attribute for the applicable\r\nsubentry to have a value of ",(0,i.jsx)(t.code,{children:"TRUE"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["By modifying the entry via the ",(0,i.jsx)(t.code,{children:"changePassword"})," operation","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If this is performed within a password administrative area, this requires\r\nthe ",(0,i.jsx)(t.code,{children:"pwdChangeAllowed"})," operational attribute for the applicable subentry to\r\nhave a value of ",(0,i.jsx)(t.code,{children:"TRUE"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["By modifying the entry via the ",(0,i.jsx)(t.code,{children:"administerPassword"})," operation","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["In addition to requiring permission to add / modify / delete the ",(0,i.jsx)(t.code,{children:"userPwd"}),"\r\nand ",(0,i.jsx)(t.code,{children:"userPassword"})," values, as is the case for the other three, this option\r\nalso requires the same permissions for the ",(0,i.jsx)(t.code,{children:"userPwdHistory"})," attribute."]}),"\n",(0,i.jsx)(t.li,{children:"Note that, when this operation is used, the user will have to reset his or\r\nher password upon logging in again."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["It is recommended to use the ",(0,i.jsx)(t.code,{children:"administerPassword"})," and/or ",(0,i.jsx)(t.code,{children:"changePassword"}),"\r\noperations to modify an entry's password, rather than the ",(0,i.jsx)(t.code,{children:"modifyEntry"})," or\r\n",(0,i.jsx)(t.code,{children:"addEntry"})," operations."]}),"\n",(0,i.jsx)(t.h2,{id:"password-policy",children:"Password Policy"}),"\n",(0,i.jsx)(t.p,{children:"Meerkat DSA allows you to configure password policy exactly as described in ITU\r\nRecommendations X.501 and X.520."}),"\n",(0,i.jsx)(t.h3,{id:"password-dictionaries",children:"Password Dictionaries"}),"\n",(0,i.jsxs)(t.p,{children:["You can configure password vocabulary by adding entries to the\r\n",(0,i.jsx)(t.code,{children:"passwordDictionaryItem"}),' table in the database (usually MySQL), along with a\r\n"bit number" indicating the category in which the vocabulary item appears,\r\naccording to the syntax of the ',(0,i.jsx)(t.code,{children:"pwdVocabulary"})," operational attribute, which is:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-asn1",children:"PwdVocabulary ::= BIT STRING {\r\n  noDictionaryWords (0),\r\n  noPersonNames (1),\r\n  noGeographicalNames (2) }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This means that, if you set the ",(0,i.jsx)(t.code,{children:"bit"})," to ",(0,i.jsx)(t.code,{children:"2"}),', the row that you create will be\r\nconsidered a "geographical name." ',(0,i.jsx)(t.strong,{children:"Password dictionary items inserted into the\r\ndatabase MUST be upper-cased, or they will have no effect."})]}),"\n",(0,i.jsxs)(t.p,{children:["There is no way to configure password dictionaries via DAP, currently. The\r\n",(0,i.jsx)(t.code,{children:"pwdDictionaries"})," is purely informative and is not used by the directory in any\r\nway."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsx)(t.p,{children:'It is recommended that you DO NOT use this operational attribute, as it goes\r\nagainst modern guidance on password-based authentication. Namely, it is actually\r\nrecommended to construct passwords from four or more dictionary words, as such\r\npasswords are more memorable, yet provide much more entropy than the\r\nprior guidance of the "8 characters minimum, at least one digit, at least one\r\nsymbol, etc." password.'})}),"\n",(0,i.jsx)(t.h3,{id:"password-lockouts",children:"Password Lockouts"}),"\n",(0,i.jsxs)(t.p,{children:["Meerkat DSA fully supports password lockouts, as described in\r\n",(0,i.jsx)(t.a,{href:"https://www.itu.int/rec/T-REC-X.511/en",children:"ITU Recommendation X.511 (2019)"}),'. This\r\nmeans that administrators can configure their directories to "lock out" users\r\nafter so many failed authentication attempts.']}),"\n",(0,i.jsxs)(t.p,{children:["To enable password lockouts, just set the ",(0,i.jsx)(t.code,{children:"pwdMaxFailures"})," operational attribute\r\non the applicable password administration subentries. You can make the lockout\r\ntemporary using the ",(0,i.jsx)(t.code,{children:"pwdLockoutDuration"})," operational attribute, if desired."]}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:["Enabling password lockouts might not be a good idea. This feature can allow\r\nnefarious users to purposefully guess wrong passwords for other users to lock\r\nthem out of their accounts. It may be a good idea to refrain from enabling this\r\nunless you are having problems with brute-force attacks, and even then, the\r\n",(0,i.jsx)(t.code,{children:"pwdLockoutDuration"})," should be set to a low value to ensure that accounts are\r\nautomatically unlocked after a short period of time."]})}),"\n",(0,i.jsx)(t.h2,{id:"strong-authentication",children:"Strong Authentication"}),"\n",(0,i.jsx)(t.p,{children:"Meerkat DSA supports strong authentication. If a certification path is supplied,\r\nthis is used to verify the signature and trustworthiness of the bind token\r\nprovided in strong authentication."}),"\n",(0,i.jsxs)(t.p,{children:["If a certification path is ",(0,i.jsx)(t.em,{children:"not"})," supplied in the bind argument, but a name ",(0,i.jsx)(t.em,{children:"is"}),"\r\nsupplied (via the ",(0,i.jsx)(t.code,{children:"name"})," parameter), and if the environment variable\r\n",(0,i.jsx)(t.a,{href:"/directory/docs/env#meerkat_lookup_uncert_strong_auth",children:(0,i.jsx)(t.code,{children:"MEERKAT_LOOKUP_UNCERT_STRONG_AUTH"})})," is\r\nset to ",(0,i.jsx)(t.code,{children:"1"})," (enabled), Meerkat DSA searches internally for a user by the asserted\r\ndistinguished name; if this user is found, and it is of object class\r\n",(0,i.jsx)(t.code,{children:"pkiCertPath"}),", and it has an attribute of type ",(0,i.jsx)(t.code,{children:"pkiPath"}),", each value of its\r\n",(0,i.jsx)(t.code,{children:"pkiPath"})," attribute is tried until a certification path is found that verifies\r\nthe bind token. If no such vindicating certification path is found, Meerkat DSA\r\nrejects the authentication attempt. It is strongly preferred for clients to\r\nsupply a certification path in the bind argument so that this lookup need not\r\nhappen."]}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:["Enabling the above feature is risky, since it can open your DSA up to\r\ndenial-of-service attacks. See more\r\n",(0,i.jsx)(t.a,{href:"/directory/docs/env#meerkat_lookup_uncert_strong_auth",children:"here"}),"."]})}),"\n",(0,i.jsxs)(t.p,{children:["The certification path is verified with the trust anchors configured in\r\n",(0,i.jsx)(t.a,{href:"/directory/docs/env#meerkat_signing_ca_file",children:(0,i.jsx)(t.code,{children:"MEERKAT_SIGNING_CA_FILE"})}),". If this environment\r\nvariable is not configured, the bundle of certificates that are built in to\r\nthe NodeJS runtime are used by default."]}),"\n",(0,i.jsxs)(t.p,{children:["If ",(0,i.jsx)(t.a,{href:"/directory/docs/env#meerkat_signing_disable_verification",children:(0,i.jsx)(t.code,{children:"MEERKAT_SIGNING_DISABLE_VERIFICATION"})}),"\r\nis enabled (meaning that all signature verification is disabled in Meerkat DSA),\r\nstrong authentication will always fail."]}),"\n",(0,i.jsx)(t.h2,{id:"spkm-authentication",children:"SPKM Authentication"}),"\n",(0,i.jsxs)(t.p,{children:["Meerkat DSA supports SPKM Authentication, but does not use it when binding to\r\nother DSAs. It is almost identical in functionality and security to strong\r\nauthentication, except that it is based on existing standards exterior to the\r\nX.500 specifications. If you need high-security authentication, prefer the\r\n",(0,i.jsx)(t.code,{children:"strong"})," mechanism over ",(0,i.jsx)(t.code,{children:"spkm"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"external-authentication",children:"External Authentication"}),"\n",(0,i.jsxs)(t.p,{children:["Meerkat DSA supports the ",(0,i.jsx)(t.code,{children:"externalProcedure"})," authentication mechanism described\r\nin ",(0,i.jsx)(t.a,{href:"https://www.itu.int/rec/T-REC-X.511/en",children:"ITU Recommendation X.511 (2019)"}),".\r\nThis mechanism is an intentionally open-ended and extensible mechanism for\r\nauthentication. The parameter for an ",(0,i.jsx)(t.code,{children:"externalProcedure"})," authentication is an\r\nASN.1 ",(0,i.jsx)(t.code,{children:"EXTERNAL"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Meerkat DSA only uses an ",(0,i.jsx)(t.code,{children:"EXTERNAL"})," value that uses the ",(0,i.jsx)(t.code,{children:"syntax"})," alternative of\r\nthe ",(0,i.jsx)(t.code,{children:"identification"})," field. When encoded according to the encoding rules\r\ndetailed in ITU Recommendation X.690, such as the Basic Encoding Rules, this\r\nfield is referred to as the ",(0,i.jsx)(t.code,{children:"direct-reference"})," field. If the\r\n",(0,i.jsx)(t.code,{children:"indirect-reference"})," field is supplied, or the ",(0,i.jsx)(t.code,{children:"direct-reference"})," field is not\r\nsupplied in the encoded ",(0,i.jsx)(t.code,{children:"EXTERNAL"}),' value, Meerkat DSA will respond with an\r\n"authentication mechanism unsupported" error.']}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"syntax"})," field of the ",(0,i.jsx)(t.code,{children:"EXTERNAL"})," (or ",(0,i.jsx)(t.code,{children:"direct-reference"}),' according to the\r\nX.690 parlance) is used to transmit an object identifier that identifies the\r\nexternal authentication mechanism. Meerkat DSA looks up the external\r\nauthentication procedure associated with that object identifier and calls a\r\nfunction to execute that authentication mechanism. If the mechanism is\r\nunrecognized or unsupported, Meerkat DSA will return an "authentication\r\nmechanism unsupported" error.']}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsxs)(t.p,{children:["There are two reasons that the ",(0,i.jsx)(t.code,{children:"presentation-context-id"})," is not recognized by\r\nMeerkat DSA for the external authentication procedure parameter:"]}),(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:'It would be really complicated from a code standpoint to "look up" the\r\npresentation contexts from the underlying protocol stack, especially when\r\nthat has been intentionally abstracted away from the Remote Operation\r\nService Element (ROSE).'}),"\n",(0,i.jsx)(t.li,{children:"Presentation contexts presented by the presentation layers are likely not\r\ngoing to be used for the external authentication procedure because their\r\nabstract syntaxes usually describe an application-layer protocol, not an\r\nexternal procedure."}),"\n"]}),(0,i.jsx)(t.p,{children:"If you don't understand what this means, don't worry about it."})]}),"\n",(0,i.jsx)(t.h3,{id:"tls-client-certificate-authentication",children:"TLS Client Certificate Authentication"}),"\n",(0,i.jsxs)(t.p,{children:["Meerkat DSA comes with one ",(0,i.jsx)(t.code,{children:"externalProcedure"})," authentication mechanism\r\nbuilt-in: TLS client certificate authentication. It's parameter can be described\r\nusing the following ASN.1 syntax:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-asn1",children:"id-tlsClientCertAuth OBJECT IDENTIFIER ::= { 1 3 6 1 4 1 56490 5 401 1 }\r\ntlsClientCertAuth ABSTRACT-SYNTAX ::= { NULL IDENTIFIED BY id-tlsClientCertAuth }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In other words, if you send a bind request using an ",(0,i.jsx)(t.code,{children:"externalProcedure"}),"\r\ncredential having the ",(0,i.jsx)(t.code,{children:"syntax"})," of ",(0,i.jsx)(t.code,{children:"1.3.6.1.4.1.56490.5.401.1"})," and a ",(0,i.jsx)(t.code,{children:"data-value"}),"\r\nof ",(0,i.jsx)(t.code,{children:"NULL"})," (although this part is not validated or checked at all), Meerkat DSA\r\nwill use TLS Client Certificate Authentication."]}),"\n",(0,i.jsxs)(t.p,{children:["This means that Meerkat DSA will determine the user's distinguished name from\r\nthe ",(0,i.jsx)(t.code,{children:"subject"})," field of the client certificate asserted via TLS, and consider the\r\nuser strongly-authenticated, assuming that the asserted certificate chain is\r\nvalid."]}),"\n",(0,i.jsx)(t.p,{children:"Note that, for this to be enabled, the client MUST connect over TLS, and Meerkat\r\nDSA MUST be configured to request a client certificate by either:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Setting ",(0,i.jsx)(t.a,{href:"/directory/docs/env#meerkat_tls_request_cert",children:(0,i.jsx)(t.code,{children:"MEERKAT_TLS_REQUEST_CERT"})})," to ",(0,i.jsx)(t.code,{children:"1"}),", or"]}),"\n",(0,i.jsxs)(t.li,{children:["Setting ",(0,i.jsx)(t.a,{href:"/directory/docs/env#meerkat_tls_reject_unauthorized_clients",children:(0,i.jsx)(t.code,{children:"MEERKAT_TLS_REJECT_UNAUTHORIZED_CLIENTS"})})," to ",(0,i.jsx)(t.code,{children:"1"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["(Of course, the client, must also actually ",(0,i.jsx)(t.em,{children:"send"})," the client certificate. That\r\nis implied.)"]}),"\n",(0,i.jsx)(t.h3,{id:"custom-external-authentication-procedures",children:"Custom External Authentication Procedures"}),"\n",(0,i.jsxs)(t.p,{children:["You can add your own external authentication procedures in the\r\n",(0,i.jsx)(t.a,{href:"/directory/docs/env#meerkat_init_js",children:"init script"}),". An external authentication procedure\r\nfunction has a signature like so:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"type ExternalAuthFunction = (\r\n    ctx: Context, // The context object\r\n    socket: Socket | TLSSocket, // The TCP or TLS socket underlying the association with the client.\r\n    ext: EXTERNAL, // The EXTERNAL that is the parameter of the `externalProcedure` credential.\r\n    // Set to DirectoryBindError for DAP, and DSABindError otherwise.\r\n    BindErrorClass: (typeof DirectoryBindError) | (typeof DSABindError),\r\n) => Promise<BindReturn>;\r\n\r\n// This is what is returned from such a function.\r\ninterface BindReturn {\r\n    /**\r\n     * The bound vertex, which will only be set if this DSA has the bound DSE\r\n     * locally.\r\n     *\r\n     * Defined in @wildboar/meerkat-types.\r\n     */\r\n    boundVertex?: Vertex;\r\n\r\n    /**\r\n     * The bound distinguished name and optional unique identifier. The\r\n     * distinguished name will be set even if the user provided no credentials\r\n     * to prove that they were that entry. The unique identifier will be set if\r\n     * a local DSE having the bound distinguished name can be found and it has\r\n     * at least one `uniqueIdentifier` attribute value. The first\r\n     * `uniqueIdentifier` attribute value will be used to populate this field,\r\n     * even though there may potentially be multiple such values.\r\n     *\r\n     * Defined in @wildboar/x500/src/lib/modules/SelectedAttributeTypes/NameAndOptionalUID.ta\r\n     */\r\n    boundNameAndUID?: NameAndOptionalUID;\r\n\r\n    /**\r\n     * The level of credibility with which the user claimed to be the bound\r\n     * entry. Whether the user bound anonymously, with a password, or with a\r\n     * asymmetric cryptography will be represented here.\r\n     *\r\n     * Defined in @wildboar/x500/src/lib/modules/BasicAccessControl/AuthenticationLevel.ta\r\n     */\r\n    authLevel: AuthenticationLevel;\r\n\r\n    /**\r\n     * Information about a user password to return in the bind response or\r\n     * error.\r\n     *\r\n     * Defined in @wildboar/x500/src/lib/modules/DirectoryAbstractService/PwdResponseValue.ta\r\n     */\r\n    pwdResponse?: PwdResponseValue;\r\n\r\n    /**\r\n     * The clearances associated with this user.\r\n     *\r\n     * Defined in @wildboar/x500/src/lib/modules/EnhancedSecurity/Clearance.ta\r\n     */\r\n    clearances: Clearance[];\r\n\r\n    /**\r\n     * The credentials for the DSA to return to the client to provide mutual\r\n     * authentication.\r\n     *\r\n     * Defined in @wildboar/x500/src/lib/modules/DistributedOperations/DSACredentials.ta\r\n     */\r\n    reverseCredentials?: DSACredentials;\r\n\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If you would like an example implementation, see\r\n",(0,i.jsx)(t.a,{href:"https://github.com/Wildboar-Software/directory/blob/master/apps/meerkat/src/app/authn/external/tls_client_auth.ts",children:"this function"}),",\r\nwhich is the implementation of the TLS Client Certificate Authentication\r\nmechanism described above."]}),"\n",(0,i.jsxs)(t.p,{children:["Once you have your function defined, add it to Meerkat DSA's internal index of\r\n",(0,i.jsx)(t.code,{children:"externalProcedure"})," mechanisms in the init script like so:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'\r\nconst YOUR_MECHANISM_OID_REPLACE_ME = "1.2.3.4.5";\r\n\r\nasync function init(ctx) {\r\n  // Here, we associate the mechanism ID with the function that does the verification.\r\n  ctx.externalProcedureAuthFunctions.set(YOUR_MECHANISM_OID_REPLACE_ME, your_function);\r\n\r\n  // This is just logging, just to show you that you can do this. :)\r\n  ctx.log.info("Added my own custom external authentication mechanism");\r\n}\r\n\r\nexport default init;\n'})}),"\n",(0,i.jsx)(t.h2,{id:"architectural-details",children:"Architectural Details"}),"\n",(0,i.jsx)(t.p,{children:"You might notice that it can take a few seconds to authenticate to Meerkat DSA.\r\nThis is no accident."}),"\n",(0,i.jsxs)(t.p,{children:["Authentication is protected against\r\n",(0,i.jsx)(t.a,{href:"https://ropesec.com/articles/timing-attacks/",children:"timing attacks"})," by response time\r\nrandomization and constant-time string comparison. (These two methods may seem\r\nto contradict each other, and you'd be right to point that out; however, both\r\nare used so that, if one does not work, the other will.) By default, Meerkat DSA\r\nalways waits one second, but potentially up to two seconds, before responding\r\nwith an authentication result. Response time randomization can be configured by administrators via the ",(0,i.jsx)(t.code,{children:"MEERKAT_BIND_MIN_SLEEP_MS"}),"\r\nand ",(0,i.jsx)(t.code,{children:"MEERKAT_BIND_SLEEP_RANGE_MS"})," environment variables."]}),"\n",(0,i.jsx)(t.p,{children:"Notably, Meerkat DSA does not sleep for a random amount of time, perform the\r\ncredential evaluation, then return a result; it performs a credential evaluation\r\nthen waits the remaining amount of time such that the randomly-selected sleep\r\ntime has passed. If the former methodology were used, nefarious actors could\r\nstill perform a timing attack by attempting authentication many times to see\r\nwhich attempts take the longest response time on average."})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1184:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(4041);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);