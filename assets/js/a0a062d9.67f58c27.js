"use strict";(self.webpackChunkdirectory=self.webpackChunkdirectory||[]).push([[3039],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,p=d["".concat(l,".").concat(m)]||d[m]||h[m]||r;return n?i.createElement(p,o(o({ref:t},u),{},{components:n})):i.createElement(p,o({ref:t},u))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1270:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],s={},l="Authorization",c={unversionedId:"authorization",id:"authorization",title:"Authorization",description:"Meerkat supports all access control schemes defined in the X.500 specifications,",source:"@site/docs/authorization.md",sourceDirName:".",slug:"/authorization",permalink:"/directory/docs/authorization",draft:!1,editUrl:"https://github.com/Wildboar-Software/directory/edit/main/website/docs/authorization.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Database Administration",permalink:"/directory/docs/database"},next:{title:"Authentication",permalink:"/directory/docs/authentication"}},u={},d=[{value:"Enabling Access Controls",id:"enabling-access-controls",level:2},{value:"Getting Locked Out",id:"getting-locked-out",level:2},{value:"Disabling Access Controls",id:"disabling-access-controls",level:3},{value:"Deleting an ACI Item from the database",id:"deleting-an-aci-item-from-the-database",level:3},{value:"Access Controls in Hierarchical Operational Bindings",id:"access-controls-in-hierarchical-operational-bindings",level:2},{value:"Recommendation Access Control",id:"recommendation-access-control",level:2},{value:"Access Control in a Distributed Environment",id:"access-control-in-a-distributed-environment",level:2},{value:"Setting the Local Qualifier of a Client",id:"setting-the-local-qualifier-of-a-client",level:2},{value:"Rule-Based Access Control",id:"rule-based-access-control",level:2},{value:"Controlling Access to Entries",id:"controlling-access-to-entries",level:3},{value:"Where Clearances Come From",id:"where-clearances-come-from",level:3},{value:"Labelling Authorities and Clearance Authorities",id:"labelling-authorities-and-clearance-authorities",level:3},{value:"The Simple Security Policy",id:"the-simple-security-policy",level:3},{value:"Custom Security Policies",id:"custom-security-policies",level:3},{value:"Chaining Rule-Based Access Control",id:"chaining-rule-based-access-control",level:3},{value:"Users with No Clearance",id:"users-with-no-clearance",level:3},{value:"Invalid Hashes, Untrusted Labels, and Untrusted Labelling Authorities",id:"invalid-hashes-untrusted-labels-and-untrusted-labelling-authorities",level:3},{value:"Unrecognized Policies",id:"unrecognized-policies",level:3},{value:"Multiple Security Labels",id:"multiple-security-labels",level:3}],h={toc:d},m="wrapper";function p(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)(m,(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"authorization"},"Authorization"),(0,r.kt)("p",null,"Meerkat supports all access control schemes defined in the X.500 specifications,\nmeaning:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Basic Access Control"),(0,r.kt)("li",{parentName:"ul"},"Simplified Access Control"),(0,r.kt)("li",{parentName:"ul"},"Rule-Based Access Control"),(0,r.kt)("li",{parentName:"ul"},"Rule-and-Basic Access Control"),(0,r.kt)("li",{parentName:"ul"},"Rule-and-Simple Access Control.")),(0,r.kt)("p",null,"Future versions of Meerkat DSA may introduce new access control schemes, like:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'A "points-based" access control scheme'),(0,r.kt)("li",{parentName:"ul"},'An "OpenLDAP-like" access control scheme')),(0,r.kt)("p",null,"This documentation will not discuss how Basic Access Control or Simplified\nAccess Control works; only the implementation-specific details that apply to\nMeerkat DSA."),(0,r.kt)("h2",{id:"enabling-access-controls"},"Enabling Access Controls"),(0,r.kt)("p",null,"Access control does not exist in Meerkat DSA (and the directory as a whole) by\ndefault. It must be configured. For Meerkat DSA to observe access controls for a\ngiven Access Control Specific Area (ACSA), the following must be in place:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"There must be an administrative point defined with an ",(0,r.kt)("inlineCode",{parentName:"li"},"administrativeRole"),"\nattribute value of ",(0,r.kt)("inlineCode",{parentName:"li"},"id-ar-autonomousArea")," (2.5.23.1)."),(0,r.kt)("li",{parentName:"ol"},"There must be an administrative point defined with an ",(0,r.kt)("inlineCode",{parentName:"li"},"administrativeRole"),"\nattribute value of ",(0,r.kt)("inlineCode",{parentName:"li"},"id-ar-accessControlSpecificArea")," (2.5.23.2). The entry\nused for this administrative point may be the same as the entry used for the\nautonomous administrative point. (An administrative point may have multiple\nroles.)"),(0,r.kt)("li",{parentName:"ol"},"The access control administrative point must have an ",(0,r.kt)("inlineCode",{parentName:"li"},"accessControlScheme"),"\nattribute value set to the object identifier of the access control scheme\nyou want to use in that administrative area.")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Note that the ACI items should be created before enabling access control. If\nthere are no ACI items defined at all, then ",(0,r.kt)("em",{parentName:"p"},"nobody")," is permitted to do\n",(0,r.kt)("em",{parentName:"p"},"anything"),". It is possible for administrators to accidentally configure\nrules that prevent even themselves from accessing their own DSA!")),(0,r.kt)("h2",{id:"getting-locked-out"},"Getting Locked Out"),(0,r.kt)("p",null,"If an administrator gets locked out of Meerkat DSA by having misconfigured\naccess controls, it will have to be corrected by directly modifying the\ndatabase to achieve one of the following goals:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To ensure that one of the conditions stated above for enabling access controls\nis no longer met, and thereby disable authorization for that ACSA entirely."),(0,r.kt)("li",{parentName:"ul"},"To delete the offending ACI item.")),(0,r.kt)("p",null,"The former option should be used when administrators don't know what they did\nwrong, or when the ACSA does not contain any private information; it is quicker\nand easier to just disable access control entirely, fix the problem, then\nre-enable access controls once it is fixed. If administrators know which ACI\nitem is causing them to be locked out, the latter option may preferrable."),(0,r.kt)("p",null,'One way you can "delete" an ACI item is by changing the ',(0,r.kt)("inlineCode",{parentName:"p"},"active")," column in the\n",(0,r.kt)("inlineCode",{parentName:"p"},"ACIItem")," table in the database to ",(0,r.kt)("inlineCode",{parentName:"p"},"FALSE")," for that ACI item."),(0,r.kt)("h3",{id:"disabling-access-controls"},"Disabling Access Controls"),(0,r.kt)("p",null,"The easiest way to do this with minimal loss of data is to delete the\naccess control scheme attribute value from the ",(0,r.kt)("inlineCode",{parentName:"p"},"EntryAccessControlScheme")," table.\nThe administrator will have to determine the ID of the entry that is the\nadministrative point for the ACSA so he can delete the correct access control\nscheme value. It may be helpful to inspect the ",(0,r.kt)("inlineCode",{parentName:"p"},"EntryAdministrativeRole")," table\nto determine the ID of the offending administrative point."),(0,r.kt)("p",null,"Note that Meerkat DSA will have to be restarted for this change to take effect,\nsince the access control scheme may still be cached in memory."),(0,r.kt)("h3",{id:"deleting-an-aci-item-from-the-database"},"Deleting an ACI Item from the database"),(0,r.kt)("p",null,"ACI items may be deleted from the ",(0,r.kt)("inlineCode",{parentName:"p"},"ACIItem")," table."),(0,r.kt)("p",null,"Note that Meerkat DSA may have to be restarted for this change to take effect,\nsince the ACI items may still be cached in memory."),(0,r.kt)("p",null,'Another way you can "delete" an ACI item is by changing the ',(0,r.kt)("inlineCode",{parentName:"p"},"active")," column in\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"ACIItem")," table in the database to ",(0,r.kt)("inlineCode",{parentName:"p"},"FALSE")," for that ACI item."),(0,r.kt)("h2",{id:"access-controls-in-hierarchical-operational-bindings"},"Access Controls in Hierarchical Operational Bindings"),(0,r.kt)("p",null,"When Meerkat DSA establishes itself as a subordinate DSA in a Hierarchical\nOperational Binding (HOB), it will honor all administrative points that lie\nwithin the naming context up until and including the closest Autonomous\nAdministrative Point (AAP). In other words, if a Meerkat DSA does not define its\nnewly minted context prefix to be an Autonomous Administrative Point (AAP), it\nmay be governed by the access controls (and other administrative controls) of\nthe superior DSA. To be clear, this is the correct behavior for an X.500\ndirectory--not an accidental nuance of Meerkat DSA. Unless you are okay with\nthe superior DSA having ",(0,r.kt)("em",{parentName:"p"},"complete control")," over the subordinate naming context\nthat you establish with it, you should define each new context prefix to be\nan Autonomous Administrative Point (AAP) and each should be an access control\nadministrative point with the desired access controls configured."),(0,r.kt)("p",null,"Everything stated above will also apply to Non-Specific Hierarchical Operational\nBindings (NHOBs), even though these are not yet supported in Meerkat DSA."),(0,r.kt)("p",null,"To clarify with an example, let's say that the administrator for C=US wishes to\nestablish your DSA as the owner of ",(0,r.kt)("inlineCode",{parentName:"p"},"C=US,ST=FL")," and everything below it. He does\nthis by submitting an ",(0,r.kt)("inlineCode",{parentName:"p"},"addEntry")," request to his DSA with ",(0,r.kt)("inlineCode",{parentName:"p"},"targetSystem")," set to\nyour DSA, which triggers his DSA to attempt to establish an HOB with your DSA.\nIf you accept the hierarchical operational binding, the DSA for ",(0,r.kt)("inlineCode",{parentName:"p"},"C=US")," will now\nredirect (chain) all operations within the namespace ",(0,r.kt)("inlineCode",{parentName:"p"},"C=US,ST=FL")," to your DSA."),(0,r.kt)("p",null,"If the administrator for ",(0,r.kt)("inlineCode",{parentName:"p"},"C=US")," has defined an Access Control Specific Area\n(ACSA) with ",(0,r.kt)("inlineCode",{parentName:"p"},"C=US")," as the administrative point that makes ",(0,r.kt)("inlineCode",{parentName:"p"},"C=US,ST=FL,L=Tampa"),"\nworld-writeable, the DSA for ",(0,r.kt)("inlineCode",{parentName:"p"},"C=US,ST=FL")," would still honor this configuration,\nand permit all writes to ",(0,r.kt)("inlineCode",{parentName:"p"},"C=US,ST=FL,L=Tampa")," even though the rule permitting it\nis external and superior to your DSA. The creation of an\nAutonomous Administrative Point (AAP) that halts the propagation of access\ncontrol rules (ACI items, for instance) from superior DSAs would prevent this\nbehavior."),(0,r.kt)("h2",{id:"recommendation-access-control"},"Recommendation Access Control"),(0,r.kt)("p",null,"While DSA administrators will likely use their DSAs differently, there are a few\ncommonalities particular to access controls that almost all uses of X.500\ndirectory services will find useful. For use common use cases, access controls\nshould be defined that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Allow administrators to administer."),(0,r.kt)("li",{parentName:"ul"},"Allow users to change their password.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"There are perfectly good arguments to ",(0,r.kt)("em",{parentName:"li"},"not")," allowing this, too. It may be\npreferrable to have secure system-generated passwords instead; in this case,\nadministrators should implement access controls that ",(0,r.kt)("em",{parentName:"li"},"prevent")," users from\nmodifying their passwords so that a service can do this on their behalf."))),(0,r.kt)("li",{parentName:"ul"},"Explicitly prohibit users from changing the passwords of others."),(0,r.kt)("li",{parentName:"ul"},"Explicitly allow administrators to change the passwords of others."),(0,r.kt)("li",{parentName:"ul"},"Allow users to read their entire entry.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This should include the child entries if the user's entry is a compound\nentry."))),(0,r.kt)("li",{parentName:"ul"},"Allow users to modify certain attributes of their entry.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For example, administrators may not want users to be able to change their\n",(0,r.kt)("inlineCode",{parentName:"li"},"employeeID")," attribute, but may want to allow users to change their\nemergency contact information as they please."))),(0,r.kt)("li",{parentName:"ul"},"Explicitly prohibit users from adding new entries, except within permitted\nsubtrees."),(0,r.kt)("li",{parentName:"ul"},"Explicitly prohibit users from modifying or deleting entries that they did not\nauthor."),(0,r.kt)("li",{parentName:"ul"},"Carefully choose which users can modify ",(0,r.kt)("inlineCode",{parentName:"li"},"hierarchyParent")," and\n",(0,r.kt)("inlineCode",{parentName:"li"},"aliasedEntryName"),", because these attributes could be used to initiate attacks\nagainst the directory (e.g. trying to exploit a bug in access control by\nusing aliases or attempting to enumerate entries with timing attacks via the\n",(0,r.kt)("inlineCode",{parentName:"li"},"hierarchyParent")," attribute validation.)"),(0,r.kt)("li",{parentName:"ul"},"Explicitly prohibit users from modifying the ",(0,r.kt)("inlineCode",{parentName:"li"},"clearance")," attribute.")),(0,r.kt)("h2",{id:"access-control-in-a-distributed-environment"},"Access Control in a Distributed Environment"),(0,r.kt)("p",null,"Meerkat DSA makes access control decisions based upon local information, but, in\na distributed environment, authentication information may come from other DSAs.\nHow this authentication information itself is authenticated is a topic in its\nown right, which is documented\n",(0,r.kt)("a",{parentName:"p",href:"/directory/docs/distributed#authentication-of-distributed-operations"},"here"),"."),(0,r.kt)("h2",{id:"setting-the-local-qualifier-of-a-client"},"Setting the Local Qualifier of a Client"),(0,r.kt)("p",null,"The meaning of the ",(0,r.kt)("inlineCode",{parentName:"p"},"localQualifier")," component of the ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthenticationLevel")," as\ndescribed in ",(0,r.kt)("a",{parentName:"p",href:"https://www.itu.int/rec/T-REC-X.501/en"},"ITU Recommendation X.501 (2019)"),",\nSection 18.4.2.3, is left to DSA implementations. In Meerkat DSA the\n",(0,r.kt)("inlineCode",{parentName:"p"},"localQualifier")," is given a value depending on the level of transport security\nthat is used to protect a connection with a client."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"localQualifier"),' is a simple integer, and Meerkat DSA adds "points" to this\ninteger, depending on configuration. A different number of points may be granted\nfor more or less secure transports. For instance, TLSv1.3 could be (and usually\nshould be) granted more ',(0,r.kt)("inlineCode",{parentName:"p"},"localQualifier"),' "points" than SSLv3, which is\ncompletely insecure (but better than nothing).'),(0,r.kt)("p",null,"The environment variables that are used to configure the ",(0,r.kt)("inlineCode",{parentName:"p"},"localQualifier")," are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkatlocalqualifierpointsforusingssl3"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_LOCAL_QUALIFIER_POINTS_FOR_USING_SSL3"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkatlocalqualifierpointsforusingstarttls"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_LOCAL_QUALIFIER_POINTS_FOR_USING_STARTTLS"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkatlocalqualifierpointsforusingtls"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_LOCAL_QUALIFIER_POINTS_FOR_USING_TLS"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkatlocalqualifierpointsforusingtls10"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_LOCAL_QUALIFIER_POINTS_FOR_USING_TLS_1_0"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkatlocalqualifierpointsforusingtls11"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_LOCAL_QUALIFIER_POINTS_FOR_USING_TLS_1_1"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkatlocalqualifierpointsforusingtls12"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_LOCAL_QUALIFIER_POINTS_FOR_USING_TLS_1_2"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkatlocalqualifierpointsforusingtls13"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_LOCAL_QUALIFIER_POINTS_FOR_USING_TLS_1_3")))),(0,r.kt)("h2",{id:"rule-based-access-control"},"Rule-Based Access Control"),(0,r.kt)("p",null,"Rule-Based Access Control is intentionally vague as to how a clearance value is\ncompared to a security label: it is open-ended by being left to the security\npolicy to determine how this comparison is performed. This means that Meerkat\nDSA must use a means for mapping a security policy identifier (which is an\nobject identifier) to a function that is used to compare the user's clearance\nwith the security label."),(0,r.kt)("h3",{id:"controlling-access-to-entries"},"Controlling Access to Entries"),(0,r.kt)("p",null,"The X.500 specifications state that access to a given entry is denied under\nRule-Based Access Control when access to all attribute values is denied.\nHowever, enforcing this would be devastating from a performance perspective.\nWhen performing a ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," operation, Meerkat DSA would have to check what might\nbe thousands of attributes per entry. Instead, Meerkat DSA denies access to\nan entry if access to any of its distinguished values are denied. This is much\nfaster, since usually only one single value is evaluated, and it is technically\nmore strict from a security perspective."),(0,r.kt)("h3",{id:"where-clearances-come-from"},"Where Clearances Come From"),(0,r.kt)("p",null,"Clearances may be associated with a user in three ways:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"By being present as attribute values of the ",(0,r.kt)("inlineCode",{parentName:"li"},"clearance")," attribute in the\nentry within the bound DSA, so long as the\n",(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkat_get_clearances_from_dsait"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_GET_CLEARANCES_FROM_DSAIT")),"\nenvironment variable is not set to ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,r.kt)("li",{parentName:"ol"},"By being present as attribute values of the ",(0,r.kt)("inlineCode",{parentName:"li"},"clearance")," attribute in the\nX.509 public key certificate asserted by the user upon successful strong\nauthentication, so long as the\n",(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkat_get_clearances_from_pkc"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_GET_CLEARANCES_FROM_PKC")),"\nenvironment variable is not set to ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,r.kt)("li",{parentName:"ol"},"By being present as attribute values of the ",(0,r.kt)("inlineCode",{parentName:"li"},"clearance")," attribute in the\nattribute certificate asserted by the user upon successful strong\nauthentication, so long as the\n",(0,r.kt)("a",{parentName:"li",href:"/directory/docs/env#meerkat_get_clearances_from_attr_certs"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_GET_CLEARANCES_FROM_ATTR_CERTS")),"\nenvironment variable is not set to ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),".")),(0,r.kt)("h3",{id:"labelling-authorities-and-clearance-authorities"},"Labelling Authorities and Clearance Authorities"),(0,r.kt)("p",null,'Security labels are signed data structures. Their signatures are generally\nproduced by the public keys of "labelling authorities." Clearances do not have\nto be signed, since they can be taken from the DSAIT, but generally, they should\nbe signed by being presented in an X.509 public key certificate or attribute\ncertificate asserted by a user during strong authentication. Thus, for both\nverifying security labels and clearance values, there is a need for Meerkat DSA\nto have a configurable set of trust anchors explicitly for the purposes of\nlabelling and clearance issuance.'),(0,r.kt)("p",null,"This can be done by pointing to Trust Anchor List files by using the\n",(0,r.kt)("a",{parentName:"p",href:"/directory/docs/env#meerkat_clearance_authorities"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_CLEARANCE_AUTHORITIES"))," and\n",(0,r.kt)("a",{parentName:"p",href:"/directory/docs/env#meerkat_labelling_authorities"},(0,r.kt)("inlineCode",{parentName:"a"},"MEERKAT_LABELLING_AUTHORITIES")),"\nenvironment variables."),(0,r.kt)("p",null,"If either of these are unset, they default to the trust anchors used for\nsigning."),(0,r.kt)("p",null,"To be used as a labelling authority, the configured trust anchors ",(0,r.kt)("strong",{parentName:"p"},"MUST")," have\na ",(0,r.kt)("inlineCode",{parentName:"p"},"subjectKeyIdentifier")," extension (or the equivalent ",(0,r.kt)("inlineCode",{parentName:"p"},"keyId")," field of the\n",(0,r.kt)("inlineCode",{parentName:"p"},"taInfo")," alternative); those that do not match this requirement will be ignored."),(0,r.kt)("h3",{id:"the-simple-security-policy"},"The Simple Security Policy"),(0,r.kt)("p",null,'For the sake of easy use of the Rule-Based Access Control (RBAC), Meerkat DSA\ncomes with a security policy built-in, called the "simple security policy."\nIt\'s object identifier is ',(0,r.kt)("inlineCode",{parentName:"p"},"1.3.6.1.4.1.56490.5.403.1"),". This security policy does\nnothing with security categories, and permits access to the labeled attribute\nvalue if the clearance level is greater than or equal to the clearance level\nrequired by the labeled attribute value. Unless you plan to make use of security\ncategories, this should be a sensible default for most use cases."),(0,r.kt)("p",null,'The Simple Security Policy treats the "unmarked" classification as being of\nhigher sensitivity than "unclassified," but of lesser sensitivity than\n"restricted." The rationale for this is that "unclassified" explicitly names\nsomething as having the most relaxed classification, whereas "unmarked" is an\nabsence of information, but it may also indicate that the labeled thing is not\nimportant enough to have labeled properly in the first place, hence, it lies\nbetween total declassification and the "restricted" classification.'),(0,r.kt)("p",null,"The Simple Security Policy does not treat reads and writes differently: if\naccess is granted to read an entry, access is also granted to modify an entry.\nThere is an exception, however: any modification operation that affects a value\nwith security labels MUST be performed with top-secret clearance."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If no security policy is listed in the security label or clearance, it defaults\nto the Simple Security Policy described above.")),(0,r.kt)("h3",{id:"custom-security-policies"},"Custom Security Policies"),(0,r.kt)("p",null,"If you want to define your own security policies, you may do so in the\n",(0,r.kt)("a",{parentName:"p",href:"/directory/docs/env#meerkat_init_js"},"init script")," like demonstrated below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'\n// This is the object identifier of your security policy.\nconst your_security_policy_id = "1.3.6.1.4.1.99999.1";\n\n// The is the Access Control Decision Function (ACDF) for your security policy.\n// This determines how a clearance value compares to a security label.\n\nconst your_custom_acdf = (\n    ctx, // Context\n    assn, // ClientAssociation // This has a clearance field.\n    target, // Vertex\n    signedLabel, // SignedSecurityLabel\n    value, // ASN1Element\n    contexts, // X500Context[]\n    permissions, // number[]\n): boolean => {\n    const label = signedLabel.toBeSigned.securityLabel;\n    const classification = Number(label.security_classification ?? SecurityClassification_unmarked);\n    if (classification === SecurityClassification_unclassified) {\n        return true; // If unclassified, the user may always see it.\n    }\n    let highestClearanceLevel: number = 0;\n    // Note that a client may be associated with multiple clearance values.\n    // How you handle this is up to you.\n    for (const clearance of assn.clearances) {\n        if (!clearance.policyId.toString() !== your_security_policy_id) {\n            // We ignore clearances that do not pertain to this security policy.\n            continue;\n        }\n        const clearanceLevel: SecurityClassification = (() => {\n            if (!clearance.classList) {\n                return SecurityClassification_unclassified;\n            }\n            else if (clearance.classList[ClassList_topSecret] === TRUE_BIT) {\n                return SecurityClassification_top_secret;\n            }\n            else if (clearance.classList[ClassList_secret] === TRUE_BIT) {\n                return SecurityClassification_secret;\n            }\n            else if (clearance.classList[ClassList_confidential] === TRUE_BIT) {\n                return SecurityClassification_confidential;\n            }\n            else if (clearance.classList[ClassList_restricted] === TRUE_BIT) {\n                return SecurityClassification_restricted;\n            }\n            else if (clearance.classList[ClassList_unmarked] === TRUE_BIT) {\n                return SecurityClassification_unmarked;\n            }\n            else {\n                return SecurityClassification_unclassified;\n            }\n        })();\n        if (clearanceLevel > highestClearanceLevel) {\n            highestClearanceLevel = Number(clearanceLevel);\n        }\n    }\n    // Just to make sure that classification cannot be given a large,\n    // illegitimate value to make a protected value universally inaccessible.\n    if (highestClearanceLevel == SecurityClassification_top_secret) {\n        return true;\n    }\n    return (highestClearanceLevel >= classification);\n}\n\nasync function init(ctx) {\n  // Here, we associate the policy ID with the ACDF\n  ctx.rbacPolicies.set(your_security_policy_id, your_custom_acdf);\n\n  // This is just logging, just to show you that you can do this. :)\n  ctx.log.info("Added my own custom security policy");\n}\n\nexport default init;\n')),(0,r.kt)("p",null,"The Access Control Decision Function (ACDF) associated with the security policy\ntakes several arguments associated with the user, attribute value, contexts, the\nDSA itself, and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean"),": if this ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", it means that\nthe user's access request was granted; if ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", the requested access is\ndenied."),(0,r.kt)("h3",{id:"chaining-rule-based-access-control"},"Chaining Rule-Based Access Control"),(0,r.kt)("p",null,"The clearances associated with a user are not preserved across the DSA boundary:\nthey are not chained. With Basic Access Control and Simplified Access Control,\nthe user's authentication level can be relayed to other DSAs, but there is no\ndefined mechanism for a users clearances to survive across chaining. As such,\nRule-Based Access Control is only viable for regulating access within a single\nDSA."),(0,r.kt)("p",null,"For security reasons, only DAP and LDAP associations will have any clearances\nassociated: this is so that downstream DSAs do not make access control decisions\non the basis of the upstream DSA's clearances rather than the originating DAP\nrequester when chaining is used."),(0,r.kt)("h3",{id:"users-with-no-clearance"},"Users with No Clearance"),(0,r.kt)("p",null,"Users with no clearances at all will automatically be given access only to\nattribute values having a security label with a class of ",(0,r.kt)("inlineCode",{parentName:"p"},"unclassified"),"."),(0,r.kt)("h3",{id:"invalid-hashes-untrusted-labels-and-untrusted-labelling-authorities"},"Invalid Hashes, Untrusted Labels, and Untrusted Labelling Authorities"),(0,r.kt)("p",null,"In Meerkat DSA, an invalid hash, invalid signature, or untrusted labelling\nauthority having issued a security label will make the security label\ninaccessible to all users not having top-secret clearance for the identified\nsecurity policy."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"When establishing the above behavior, I had--broadly speaking--two choices:"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"Generally allow access (with possible caveats) when a security label is\ninvalid for some reason."),(0,r.kt)("li",{parentName:"ol"},"Generally deny access (with possible caveats) when a security label is\ninvalid for some reason.")),(0,r.kt)("p",{parentName:"admonition"},"If I chose option 1, there would be a risk of disclosing classified information\nas a result of accidentally malformed labels or bugs in the DER encoding,\nhashing, or signing. If I chose option 2, there would be a risk of nefarious\nusers either creating illegitimate labels or copying otherwise legitimate\nlabels from correct values to cripple directory access to legitimate users."),(0,r.kt)("p",{parentName:"admonition"},"I chose option 2 for these reasons:"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"Not all malformed labels are malicious; some are produced by accident, and\nthe risk of accidentally disclosing classified information could be much\ngreater than temporarily having lost access to part of the directory."),(0,r.kt)("li",{parentName:"ol"},"Since labelled values are generally going to be created by people that\nalready have clearance for that information, there would be no immediate\nfeedback to indicate that something was wrong if access were granted for\ninvalid labels; the value would still appear to that user as expected. By\nrestricting access for invalid labels, there may be a visible consequence\nthat users can seek to rectify."),(0,r.kt)("li",{parentName:"ol"},"There is no real way to know if a label is valid until you submit it to\nMeerkat DSA. This means that users would have to add the classified\ninformation to Meerkat DSA, then determine if the labels are valid after the\nfact being checking if the classified information is disclosed to\nunauthorized users."),(0,r.kt)("li",{parentName:"ol"},"At least with the Simple Security Policy, modifying security labels in the\nfirst place is only granted to users with top-secret clearance."))),(0,r.kt)("p",null,"Note that, as a result of the above, changing the configured\n",(0,r.kt)("a",{parentName:"p",href:"/directory/docs/env#meerkat_labelling_authorities"},"labelling authorities"),' could invalidate\nexisting security labels, making values "disappear" to users that would\notherwise have access to them.'),(0,r.kt)("h3",{id:"unrecognized-policies"},"Unrecognized Policies"),(0,r.kt)("p",null,"When Meerkat DSA encounters an unrecognized policy on a security label, it\nonly grants access to the protected value if the label indicates that the\nitem is ",(0,r.kt)("inlineCode",{parentName:"p"},"unclassified")," or if the user has top-secret clearance."),(0,r.kt)("h3",{id:"multiple-security-labels"},"Multiple Security Labels"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.itu.int/rec/T-REC-X.501/en"},"ITU Recommendation X.501 (2019)"),"\nmandates a limit of one security label context per value. Meerkat DSA does not\nenforce this. The behavior of Meerkat DSA in the presence of multiple security\nlabels for a given value will remain undefined, but it usually results in the\nfirst one being used exclusively, and the remainder ignored."))}p.isMDXComponent=!0}}]);