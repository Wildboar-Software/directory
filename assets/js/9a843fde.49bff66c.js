"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8527],{1184:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(4041);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},4194:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"opbinding","title":"Operational Bindings","description":"Hierarchical Operational Bindings (HOBs)","source":"@site/docs/opbinding.md","sourceDirName":".","slug":"/opbinding","permalink":"/directory/docs/opbinding","draft":false,"unlisted":false,"editUrl":"https://github.com/Wildboar-Software/directory/edit/main/website/docs/opbinding.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Signed Operations","permalink":"/directory/docs/signing"},"next":{"title":"Shadowing","permalink":"/directory/docs/shadowing"}}');var r=i(1085),a=i(1184);const s={},o="Operational Bindings",d={},h=[{value:"Hierarchical Operational Bindings (HOBs)",id:"hierarchical-operational-bindings-hobs",level:2},{value:"Non-Specific Hierarchical Operational Bindings (NHOBs)",id:"non-specific-hierarchical-operational-bindings-nhobs",level:2},{value:"Authentication",id:"authentication",level:2},{value:"Relayed Operational Bindings",id:"relayed-operational-bindings",level:2},{value:"Authentication",id:"authentication-1",level:3},{value:"Behavior",id:"behavior",level:3},{value:"ASN.1 Specification and Formal Procedure",id:"asn1-specification-and-formal-procedure",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"operational-bindings",children:"Operational Bindings"})}),"\n",(0,r.jsx)(n.h2,{id:"hierarchical-operational-bindings-hobs",children:"Hierarchical Operational Bindings (HOBs)"}),"\n",(0,r.jsxs)(n.p,{children:["Hierarchical operational bindings may be created is through the ",(0,r.jsx)(n.code,{children:"addEntry"}),"\r\noperation with the ",(0,r.jsx)(n.code,{children:"targetSystem"})," parameter set to the access point of the\r\nsubordinate DSA to which the entry is to be added. This is a standard behavior\r\ndefined in the X.500 specifications."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"governingStructureRule"})," is supposed to be replicated from a hierarchical\r\nsuperior to a hierarchical subordinate, but in case it is not, Meerkat DSA, when\r\nacting as a subordinate DSA in a HOB will attempt to calculate the governing\r\nstructure rule from what information is replicated regarding the superior\r\nadministrative points and subentries. This applies to the context prefix and the\r\n",(0,r.jsx)(n.code,{children:"immSupr"})," DSE that is created above it."]}),"\n",(0,r.jsx)(n.h2,{id:"non-specific-hierarchical-operational-bindings-nhobs",children:"Non-Specific Hierarchical Operational Bindings (NHOBs)"}),"\n",(0,r.jsxs)(n.p,{children:["Once a Non-Specific Hierarchical Operational Binding (NHOB) is established, a\r\ndirectory user may add subordinates to it using the ",(0,r.jsx)(n.code,{children:"addEntry"})," DAP operation.\r\nThe ",(0,r.jsx)(n.code,{children:"targetSystem"})," field must be set to the access point of the DSA to which the\r\nentry shall be added, and this access point (more specifically, the AE-title of\r\nthe DSA) shall be present in the access points present in the\r\n",(0,r.jsx)(n.code,{children:"nonSpecificKnowledge"})," attribute of the Non-Specific Subordinate Reference\r\n(NSSR) entry. If the ",(0,r.jsx)(n.code,{children:"targetSystem"})," field is not present, the entry will just\r\nbe created locally, subordinate to the NSSR. If the ",(0,r.jsx)(n.code,{children:"targetSystem"})," field is\r\npresent, but it does not name of the access points participating in the NSSR,\r\na normal Hierarchical Oeprational Binding (HOB) will be established instead."]}),"\n",(0,r.jsx)(n.p,{children:"To reiterate, the procedure for adding entries to an NHOB in Meerkat DSA is\r\nas follows: if the target DSE is an NSSR:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["And the ",(0,r.jsx)(n.code,{children:"targetSystem"})," component is not present, just create a local entry."]}),"\n",(0,r.jsxs)(n.li,{children:["And the ",(0,r.jsx)(n.code,{children:"targetSystem"})," component IS present, AND:"]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"targetSystem"})," refers to one of the access points in the\r\n",(0,r.jsx)(n.code,{children:"nonSpecificKnowledge"})," attribute, forward the request to the DSA unchanged."]}),"\n",(0,r.jsxs)(n.li,{children:["The targetSystem does NOT refer to one of the access points in the\r\n",(0,r.jsx)(n.code,{children:"nonSpecificKnowledge"})," attribute, establish an HOB with the targeted DSA as\r\nusual."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"It is not clear whether this is a deviation from the X.500 specifications."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"removeEntry"})," can be used like normal to remove entries from an NHOB as usual,\r\nbut Meerkat DSA--in deviation from the X.500 specifications--will NOT terminate\r\nthe NHOB when the last subordinate entry is removed from an NHOB."]}),"\n",(0,r.jsx)(n.h2,{id:"authentication",children:"Authentication"}),"\n",(0,r.jsxs)(n.p,{children:["Operational bindings are extremely sensitive matters. For this reason, Meerkat\r\nDSA ",(0,r.jsx)(n.em,{children:"requires"})," at least simple authentication over TLS to authorize a\r\nDirectory Operational Binding Management Protocol (DOP) request. This can be\r\nconfigured via the ",(0,r.jsx)(n.code,{children:"MEERKAT_MIN_AUTH_LEVEL_FOR_OB"})," environment variable, which\r\ncontrols the authentication level required for operational bindings, and the\r\n",(0,r.jsx)(n.code,{children:"MEERKAT_MIN_AUTH_LOCAL_QUALIFIER_FOR_OB"}),", which controls the local qualifier\r\nrequired for operational bindings."]}),"\n",(0,r.jsx)(n.p,{children:'Even after this, operational bindings require acceptance. The only way to do\r\nthis currently is with the web administration console. Review the requested\r\noperational binding and click the "approve" button to approve it. If you do\r\nnot click "approve" quickly enough, the request will expire and the proposed\r\noperational binding will be rejected. Currently the timeout is five minutes,\r\nbut this will eventually be configurable.'}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"It is DANGEROUS to enable the web administration console at all. Please\r\nensure that it is only available behind a reverse proxy that requires\r\nauthentication and transport security."})}),"\n",(0,r.jsx)(n.h2,{id:"relayed-operational-bindings",children:"Relayed Operational Bindings"}),"\n",(0,r.jsxs)(n.p,{children:["The X.500 specifications define three operational bindings, and for each, two\r\nways in which they can be established ",(0,r.jsx)(n.em,{children:"in theory"}),". However, in practice, the\r\nX.500 specifications do not define any way these operational bindings can be\r\ninitiated using X.500 protocols, meaning that DSAs must define some non-standard\r\nway for DSA administrators to trigger a DSA to propose and establish an\r\noperational binding with another DSA. For instance, there is no X.500-defined\r\nprocedure for triggering a DSA to request a shadowing operational binding with\r\na supplier DSA."]}),"\n",(0,r.jsxs)(n.p,{children:["For this reason, Meerkat DSA defines a private extension to the\r\n",(0,r.jsx)(n.code,{children:"EstablishOperationalBindingResultData"})," and\r\n",(0,r.jsx)(n.code,{children:"TerminateOperationalBindingArgumentData"})," ASN.1 productions: ",(0,r.jsx)(n.code,{children:"relayTo"}),', and with\r\nit, the DSA behavior referred heretofore as "relayed operational bindings."']}),"\n",(0,r.jsxs)(n.p,{children:['Relayed Operational Bindings (ROB) requests, are "pseudo-DOP" requests received\r\nfrom a DSA admin, and signed using the DSA\'s own private key. The ',(0,r.jsx)(n.code,{children:"relayTo"}),"\r\nfield contains an access point to which the bound DSA should relay a similar\r\nDOP request of its own. In other words, a DSA admin can send the\r\n",(0,r.jsx)(n.code,{children:"establishOperationalBinding"})," or ",(0,r.jsx)(n.code,{children:"terminateOperationalBinding"})," request to the\r\nDSA they administer with the ",(0,r.jsx)(n.code,{children:"relayTo"})," field, which the DSA shall then relay,\r\npossibly after modification and re-signing, to the other DSA that is to\r\ncooperate in the operational binding."]}),"\n",(0,r.jsx)(n.p,{children:'This feature is not technically a "deviation" from the specification, since it\r\ndoes not conflict with the behaviors of the X.500 directory specifications.'}),"\n",(0,r.jsx)(n.h3,{id:"authentication-1",children:"Authentication"}),"\n",(0,r.jsxs)(n.p,{children:["As stated above, ROB requests MUST be signed and they MUST signed with the\r\n",(0,r.jsx)(n.em,{children:"bound DSA's private key"}),". Since there is no access control that applies to the\r\nDSA in general, this serves as a form of access control: a DSA administrator\r\nthat can obtain the signing private key for a DSA can demonstrate their\r\nlegitimacy to act on behalf of the DSA. Having the signing private key for a DSA\r\nbasically proves that ",(0,r.jsx)(n.em,{children:"you are the DSA"}),". Hence, a DSA that supports ROB will\r\ncheck that ROB requests are signed with its own private key before relaying\r\nsuch requests."]}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsx)(n.p,{children:"Using the DSA's private key usually entails it being installed on the device of\r\nthe X.500 DUA. This means that the private key will be present on two or more\r\ndevices, which presents a security risk. If one such device is compromised, and\r\nthe private key exfiltrated, nefarious users may act on behalf of the DSA."}),(0,r.jsx)(n.p,{children:"For this reason, it is recommended to rotate the DSA's signing key after the\r\ndesired relayed operational bindings have been established or terminated."})]}),"\n",(0,r.jsx)(n.h3,{id:"behavior",children:"Behavior"}),"\n",(0,r.jsx)(n.p,{children:'With a relayed operational binding request, the DSA reserves the right to modify\r\nthe request, so long as the "general intention" of the request is preserved.'}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"The rationale for this is that the DSA administrator's information may be\r\nincorrect or out-of-date. For instance, when populating the context prefix info\r\nof a hierarchical operational binding, the DSA administrator might have misnamed\r\nsome of the vertices or missed a subentry. In either such case, the bound DSA\r\nmay modify this request to correct for errors like these, so long as major\r\ndetails of the request are still preserved."})}),"\n",(0,r.jsxs)(n.p,{children:["You may have also noticed that the documentation above does not mention that\r\n",(0,r.jsx)(n.code,{children:"relayTo"})," is available for ",(0,r.jsx)(n.code,{children:"modifyOperationalBinding"}),". This is because, for all\r\noperational bindings defined in the X.500 specifications, there exist procedures\r\nfor a DSA to automatically update the operational bindings correspondent DSAs,\r\nnamely when entries are added, modified, or deleted. Further, the added\r\ncomplexity just isn't worth the effort and risk for a non-standard feature that\r\nmay be obviated in future X.500 specifications."]}),"\n",(0,r.jsx)(n.h3,{id:"asn1-specification-and-formal-procedure",children:"ASN.1 Specification and Formal Procedure"}),"\n",(0,r.jsxs)(n.p,{children:["The following component is added to to the ASN.1 ",(0,r.jsx)(n.code,{children:"SEQUENCE"})," types,\r\n",(0,r.jsx)(n.code,{children:"EstablishOperationalBindingResultData"})," and\r\n",(0,r.jsx)(n.code,{children:"TerminateOperationalBindingArgumentData"}),", defined in\r\n",(0,r.jsx)(n.a,{href:"https://www.itu.int/rec/T-REC-X.501/en",children:"ITU Recommendation X.501 (2019)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-asn1",children:"relayTo [PRIVATE 0] AccessPoint\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"AccessPoint"})," is defined in\r\n",(0,r.jsx)(n.a,{href:"https://www.itu.int/rec/T-REC-X.518/en",children:"ITU Recommendation X.518 (2019)"}),", in\r\nthe ",(0,r.jsx)(n.code,{children:"DistributedOperation"})," ASN.1 module."]}),"\n",(0,r.jsxs)(n.p,{children:["If the above private extension is included in an ",(0,r.jsx)(n.code,{children:"establishOperationalBinding"}),"\r\nor ",(0,r.jsx)(n.code,{children:"terminateOperationalBinding"})," request, the request is, by definition, a\r\nRelayed Operational Binding (ROB) request."]}),"\n",(0,r.jsx)(n.p,{children:"The formal procedure for handling such a request by a bound DSA is as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Validate the signatures of the request as usual, meaning both the validity\r\nof the digital signature and the PKI used to authenticate the public key that\r\nproduced it."}),"\n",(0,r.jsx)(n.li,{children:"Check that the request was signed with the bound DSA's own private signing\r\nkey. (NOT the private key used for TLS, unless this is the exact same key as\r\nis used for signing.)"}),"\n",(0,r.jsx)(n.li,{children:"Construct a new request by:"}),"\n",(0,r.jsxs)(n.li,{children:["Removing the ",(0,r.jsx)(n.code,{children:"relayTo"})," private extension. This is critical for preventing\r\nsubsequent DSAs from interpreting the relayed DOP request as yet another\r\nrelayed DOP request, which might create an infinite loop."]}),"\n",(0,r.jsx)(n.li,{children:"Correcting small errors in the request, and filling in useful details."}),"\n",(0,r.jsxs)(n.li,{children:["Updating the ",(0,r.jsx)(n.code,{children:"time"})," field of any ",(0,r.jsx)(n.code,{children:"SecurityParameters"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Changing the ",(0,r.jsx)(n.code,{children:"random"})," field of any ",(0,r.jsx)(n.code,{children:"SecurityParameters"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Re-signing the DOP request."}),"\n",(0,r.jsxs)(n.li,{children:["If the request cannot be formulated as described in step 3, or cannot be\r\nhonored for some other reason (such as the bound DSA not controlling the\r\ncontext prefix named in the ",(0,r.jsx)(n.code,{children:"HierarchicalAgreement"})," of a proposed HOB), the\r\nbound DSA shall return an ",(0,r.jsx)(n.code,{children:"operationalBindingError"})," to the user hinting at\r\nthe particular aspect of the relayed DOP request that could not be honored\r\n(e.g. use the ",(0,r.jsx)(n.code,{children:"invalidAgreement"})," problem to indicate a problem with the\r\nagreement). If this is the case, the error data's ",(0,r.jsx)(n.code,{children:"performer"})," field MUST\r\ncontain the distinguished name of the bound DSA, so as to indicate that the\r\nrequest could not be relayed at all."]}),"\n",(0,r.jsxs)(n.li,{children:["Transmit the newly-formulated DOP request to the DSA indicated by the\r\n",(0,r.jsx)(n.code,{children:"relayTo"})," parameter of the original DOP request. The bound DSA shall then,\r\nin every other way, respond to the outcome of this request as required by\r\nthe specifications, but return a response (which may differ from this\r\noutcome) to the DSA admin that requested the relayed DOP.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If a result or error is obtained, the result should be forwarded back to\r\nthe requestor unchanged."}),"\n",(0,r.jsx)(n.li,{children:"In other cases, such as rejects or aborts, the bound DSA's behavior will\r\nremain undefined by these procedures."}),"\n",(0,r.jsxs)(n.li,{children:["If the correspondent DSA cannot be reached, the response to\r\nthe DSA admin should not time out or close the association: a\r\n",(0,r.jsx)(n.code,{children:"serviceError"})," should be returned instead."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"NOTE for later: document absence of algorithm identifier in signed arguments,\r\nresults, errors, etc."}),"\n",(0,r.jsx)(n.p,{children:"4"})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);