"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6721],{1184:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(4041);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}},6001:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"distributed","title":"Distributed Operations","description":"Authentication of Distributed Operations","source":"@site/docs/distributed.md","sourceDirName":".","slug":"/distributed","permalink":"/directory/docs/distributed","draft":false,"unlisted":false,"editUrl":"https://github.com/Wildboar-Software/directory/edit/main/website/docs/distributed.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Networking","permalink":"/directory/docs/networking"},"next":{"title":"Transport Layer Security (TLS)","permalink":"/directory/docs/tls"}}');var s=n(1085),r=n(1184);const a={},o="Distributed Operations",h={},c=[{value:"Authentication of Distributed Operations",id:"authentication-of-distributed-operations",level:2},{value:"Identity-Based Requester Authentication",id:"identity-based-requester-authentication",level:3},{value:"Signature-Based Requester Authentication",id:"signature-based-requester-authentication",level:3},{value:"Restrictions that Apply to Both",id:"restrictions-that-apply-to-both",level:2},{value:"Handling of Invalid Signatures",id:"handling-of-invalid-signatures",level:2},{value:"Authentication to Other DSAs",id:"authentication-to-other-dsas",level:2},{value:"Security Risks of Chaining",id:"security-risks-of-chaining",level:2},{value:"Behavior of Signed DSP Results",id:"behavior-of-signed-dsp-results",level:2},{value:"Cross References",id:"cross-references",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"distributed-operations",children:"Distributed Operations"})}),"\n",(0,s.jsx)(t.h2,{id:"authentication-of-distributed-operations",children:"Authentication of Distributed Operations"}),"\n",(0,s.jsxs)(t.p,{children:["There are two ways defined for a DSA to authenticate the original requester of\na chained operation: either by trusted the ",(0,s.jsx)(t.code,{children:"originator"})," and ",(0,s.jsx)(t.code,{children:"authenticationLevel"}),"\nasserted by a remote DSA in its ",(0,s.jsx)(t.code,{children:"ChainingArguments"})," by fiat (which is called\nIdentity-Based Requester Authentication (IBRA)), or by validating\ndigital signatures on signed DAP arguments (which is called Signature-Based\nRequester Authentication (SBRA)). The latter is obviously more secure\nthan the former. These are described in\n",(0,s.jsx)(t.a,{href:"https://www.itu.int/rec/T-REC-X.518/en",children:"ITU Recommendation X.518 (2019)"}),",\nSection 22."]}),"\n",(0,s.jsx)(t.h3,{id:"identity-based-requester-authentication",children:"Identity-Based Requester Authentication"}),"\n",(0,s.jsxs)(t.p,{children:["In Meerkat DSA, the only way to accept a new proposed operational binding\n(currently) is via the ",(0,s.jsx)(t.a,{href:"/directory/docs/webadmin",children:"web administration console"}),'. When you\naccept an operational binding in the "Operational Bindings" section, you will\nbe able to check a box that indicates that the proposing DSA will be trusted\nfor Identity-Based Requester Authentication.']}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"This is a dangerous setting, because it means that you will trust that DSA to\nhonestly indicate the originator and authentication level. Do NOT enable this\nunless you completely trust the other DSA will ALL information in your DSA!"})}),"\n",(0,s.jsx)(t.h3,{id:"signature-based-requester-authentication",children:"Signature-Based Requester Authentication"}),"\n",(0,s.jsxs)(t.p,{children:["Unless you intentionally disable all signature validation (not recommended),\nSignature-Based Requester Authentication (SBRA) is ",(0,s.jsx)(t.em,{children:"always"})," enabled. If the\nsignature on the original DAP operation is cryptographically signed and this\nsignature is trustworthy according to the\n",(0,s.jsx)(t.a,{href:"/directory/docs/signing#configuring-signing",children:"trust anchors configured for signing"}),',\nMeerkat DSA will use the subject of the end entity certificate as the requester\nand will attribute an authentication level of "strong" to the requester, since\na valid signed argument is effectively as good as strong authentication, ',(0,s.jsx)(t.em,{children:"subject to the\nrestrictions below"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["In other words, if the DAP argument is signed, the requester's authentication\nlevel will (subject to the restrictions that follow), be equal to this\n",(0,s.jsx)(t.code,{children:"AuthenticationLevel"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-asn1",children:"withSignedDAPArgument AuthenticationLevel ::= {\n  basicLevels {\n    level strong,\n    signed TRUE\n  }\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"restrictions-that-apply-to-both",children:"Restrictions that Apply to Both"}),"\n",(0,s.jsxs)(t.p,{children:["The effective authentication level for a user will be ",(0,s.jsx)(t.em,{children:"the lesser of the level\nand localQualifier"}),' for the DAP originator and the client DSA. This is not a\nrequirement of the X.500 specifications, but a nuance of how Meerkat DSA\noperates. For example, if a requester authenticates using strong authentication,\nbut the operation is chained via a DSA that anonymously binds to another DSA to\ncontinue the operation, the request is effectively considered "anonymous,"\ndespite the original user\'s strong authentication.']}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsx)(t.p,{children:'The rationale for this is that the real authentication level of a request could\nbe argued to be the authentication of the "weakest link" as a request traverses\none or more DSAs. Therefore, if a user authenticates using strong authentication,\nbut a DSA chains their operation by authenticating to another DSA with only a\npassword, the request itself is only as authenticated as a password.'}),(0,s.jsx)(t.p,{children:"This was a design choice in line with Meerkat DSA's philosophy: whenever an\nambiguity exists in the specification, pick the more secure interpretation."})]}),"\n",(0,s.jsx)(t.p,{children:'For this reason, it is important for DSAs that cooperate to perform chaining\nshould all use strong authentication and TLS, so that the authentication levels\nof chained operations do not get "downgraded" in the eyes of Meerkat DSA.'}),"\n",(0,s.jsx)(t.h2,{id:"handling-of-invalid-signatures",children:"Handling of Invalid Signatures"}),"\n",(0,s.jsx)(t.p,{children:"Invalid / untrusted signatures on arguments are not immediately treated as\nfailures by Meerkat DSA, because signed operations that are given to a DSA may\nend up being chained to another DSA. The DSA that initially receives the signed\narguments may not be the one that actually performs the operation. However,\naccess controls are still an important aspect of name resolution. Meerkat DSA\nhas to decide, before the operation is chained to another DSA, whether a bound\nDUA even has permission to know of the existence of a given subordinate\nreference, for instance."}),"\n",(0,s.jsxs)(t.p,{children:["For this reason, when a digital signature is invalid in the eyes of a given\nMeerkat DSA instance, the authentication level attributed to the request is\ndowngraded, such that ",(0,s.jsx)(t.code,{children:"signed"})," is ",(0,s.jsx)(t.code,{children:"FALSE"}),", and the operation proceeds with the\nresulting authentication level. This means that the Find DSE procedure may\ntraverse subtrees of the DIT that are only discoverable to, say,\npassword-authenticated users, but not ones that require valid signed arguments.\nOnce the target entry is located, and operation execution has begun, the\nperforming DSA (assuming it is a Meerkat DSA instance) will check if the\nargument is signed, but the authentication level's ",(0,s.jsx)(t.code,{children:"signed"})," component is set to\n",(0,s.jsx)(t.code,{children:"FALSE"}),", which indicates that the signature is invalid. If this is the case, it\nmeans that the signature was determined to be invalid earlier (in the request\nvalidation procedure), and at that point, the operation will fail with an error,\nindicating that the signature is invalid."]}),"\n",(0,s.jsx)(t.p,{children:"That was a mouthful. To summarize: the digital signature is checked by each\nMeerkat DSA instance in a distributed operation, and if the signature is\ninvalid, the authentication level is silently downgraded to reflect that, but\nthe operation continues. If the Meerkat DSA instance that actually performs the\noperation (as opposed to merely chaining the operation to another DSA) has\ndetermined that the signature is invalid, an error is returned."}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:"To be clear, the above only applies to Meerkat DSA. This behavior is not\nspecified in the X.500 specifications, so other DSA implementations may not\nconform to the behavior described above."})}),"\n",(0,s.jsx)(t.h2,{id:"authentication-to-other-dsas",children:"Authentication to Other DSAs"}),"\n",(0,s.jsxs)(t.p,{children:["If signing is configured, Meerkat DSA will use its signing certificate and key\nto attempt strong authentication to every single DSA to which it chains. If this\nfails, Meerkat DSA will attempt credentials that are stored in the\n",(0,s.jsx)(t.code,{children:"AccessPointCredentials"})," table in the DBMS, if the targeted access point has\nconfigured credentials stored there. Otherwise, one last attempt will be made\nwith an anonymous bind."]}),"\n",(0,s.jsxs)(t.p,{children:["Populating the ",(0,s.jsx)(t.code,{children:"AccessPointCredentials"})," table has to be done manually. There is\nno way to do this using Meerkat DSA (including the web admin console), currently."]}),"\n",(0,s.jsx)(t.h2,{id:"security-risks-of-chaining",children:"Security Risks of Chaining"}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["If you allow a user to add an entry via the ",(0,s.jsx)(t.code,{children:"addEntry"})," operation and they are\nauthorization to chain operations, they might be able to spam the DSA with\n",(0,s.jsx)(t.code,{children:"targetSystem"})," values containing LAN IP addresses and make the DSA act as a\nTCP port scanner and scan the local network and submit chained requests. This\ncould be an especially bad problem if a reached TCP port will interpret bytes of\na chained request as a different protocol packet, such as a MySQL packet!"]})}),"\n",(0,s.jsx)(t.p,{children:"To prevent abuse as described above, do not generously grant permissions to\nadd entries, and require signed arguments for chaining to make it as difficult\nas possible to exploit this."}),"\n",(0,s.jsx)(t.p,{children:"You can configure the authentication required for chaining via these\nconfiguration options:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/directory/docs/env#meerkat_min_auth_level_for_chaining",children:(0,s.jsx)(t.code,{children:"MEERKAT_MIN_AUTH_LEVEL_FOR_CHAINING"})})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/directory/docs/env#meerkat_min_auth_local_qualifier_for_chaining",children:(0,s.jsx)(t.code,{children:"MEERKAT_MIN_AUTH_LOCAL_QUALIFIER_FOR_CHAINING"})})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/directory/docs/env#meerkat_signing_required_for_chaining",children:(0,s.jsx)(t.code,{children:"MEERKAT_SIGNING_REQUIRED_FOR_CHAINING"})})}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"It is also strongly advised to configure network policies that prevent Meerkat\nDSA from reaching other services on its local network that it should not be able\nto reach. This is simple to do on Kubernetes or Docker."}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["Meerkat DSA will ",(0,s.jsx)(t.strong,{children:"NOT"})," chain to a transport service that has the same port\nnumber as the DBMS, while this may seem overly restrictive, it is to prevent\nMeerkat DSA from being tricked into sending directory requests to the DBMS,\nwhich could get interpreted as, for example, MySQL packets. This has to be\nimplemented within Meerkat DSA, because you cannot block Meerkat DSA's access\nto the DBMS at the network level."]})}),"\n",(0,s.jsx)(t.h2,{id:"behavior-of-signed-dsp-results",children:"Behavior of Signed DSP Results"}),"\n",(0,s.jsx)(t.p,{children:"If Meerkat DSA receives a signed DSP result, it verifies this signature, unless\nconfigured otherwise (there are some checks that are not currently configurable)."}),"\n",(0,s.jsxs)(t.p,{children:["If the signature is found to be valid, it still may not be viable to return\ndirectly to the prior DSA. If the security parameters of the DSP result contain\na ",(0,s.jsx)(t.code,{children:"name"})," or ",(0,s.jsx)(t.code,{children:"time"})," component, they cannot be re-used, so the valid DSP result\nmust be re-signed by the local DSA. If the previous recipient is a DUA (as\nindicated by being bound using the Directory Access Protocol), the result will\nnot be re-signed, since the DSP signature will be discarded."]}),"\n",(0,s.jsx)(t.p,{children:"If the signature is found to be invalid, Meerkat DSA will not discard the\nresult, but instead, it will simply log what is wrong with the DSP result,\ndiscard any sensitive information, such as cross references, received from the\ndownstream DSA, and re-sign the DSP result."}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["This is the behavior of Meerkat DSA because, in most scenarios, this just means\nthere is a bug, misconfiguration, certificate expiration, or some other\ninfrastructure problem, rather than tampering. It would be nice to discard the\nresult and report a service error having problem ",(0,s.jsx)(t.code,{children:"unavailable"}),", but X.500\ndirectories have the option of providing completely unsigned results, and,\nparticularly for modification operations, the operation might have truly\nsucceeded in the remote DSA. Since signatures are optional anyway, it seems like\nit would only harm directory availability to discard DSP results with invalid\nsignatures."]})}),"\n",(0,s.jsx)(t.h2,{id:"cross-references",children:"Cross References"}),"\n",(0,s.jsx)(t.p,{children:'As of version 3.0.0, Meerkat DSA supports the use of cross references, which\nspeed up name resolution and operation continuation by "bookmarking" the DSAs\ninvolved in an operation and making a direct connection to them, rather than\nchaining through the first-level DSAs.'}),"\n",(0,s.jsxs)(t.p,{children:["These cross references are relayed between DSAs via the ",(0,s.jsx)(t.code,{children:"ChainingResults"})," that\nare appended to the DAP result and traverse backwards along the path taken by\nchaining. This means that, if the DSP result is signed (not just the DAP\nresult), the cross references themselves will have integrity protection in\ntransit, and if the DSP result is ",(0,s.jsx)(t.em,{children:"not"})," signed, they will ",(0,s.jsx)(t.em,{children:"not"})," have integrity\nprotection."]}),"\n",(0,s.jsx)(t.p,{children:"As any kind of routing information is extremely security-sensitive, Meerkat DSA\nwill not apply cross references unless they appear in a signed DSP result. If\nthis signed DSP result has an invalid signature, the cross references will not\nonly not be applied to the local DSAIT, but the local DSA will also discard all\nof the cross references, supply its own, and re-sign the DSP result to restore\nits validity."}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:"The cross references returned in a DSP result which has an invalid signature are\ndiscarded because they are optional and extremely security sensitive. Meerkat\nDSA will not be complicit in sharing potentially corrupted routing information\nwith other DSAs."})}),"\n",(0,s.jsxs)(t.p,{children:["Meerkat DSA will request cross references if the prior DSA in a chained\noperation requested them, or if the\n",(0,s.jsx)(t.a,{href:"/directory/docs/env#meerkat_request_cross_references",children:(0,s.jsx)(t.code,{children:"MEERKAT_REQUEST_CROSS_REFERENCES"})}),"\nconfiguration option is set to ",(0,s.jsx)(t.code,{children:"1"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["In addition to the above, all cross references are validated upon receipt. Any\ncross references that describe a context prefix that does not lie within the\npath of the ",(0,s.jsx)(t.code,{children:"targetObject"})," or that are subordinate to any naming context held\nby the local DSA."]}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:"Cross references in violation of the above validation techniques may be\nnefarious attempts to hijack namespaces that do not belong to the called DSA."})}),"\n",(0,s.jsx)(t.p,{children:"If the access point named in a cross reference becomes unreachable, Meerkat DSA\nwill remove the cross reference. A future version of Meerkat DSA will\nperiodically ignore cross references to ensure that directory routing is still\nvalid."})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);