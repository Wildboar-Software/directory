import { describe, it } from "node:test";

describe.skip("Meerkat DSA", () => {

    it.skip("A superior DSA can establish an HOB", async () => {

    });

    it.skip("A subordinate DSA can accept an HOB", async () => {

    });

    it.skip("A modification to a subordinate DSA's context prefix updates the superior DSA (Technically not required by X.500 standards)", async () => {

    });

    it.skip("A modification to a subordinate DSA's subentry under the context prefix updates the superior DSA (Technically not required by X.500 standards)", async () => {

    });

    it.skip("A modification to a context prefix's name or location results in an update to the superior DSA in an HOB", async () => {

    });

    it.skip("A modification to a context prefix's subentry's name or location results in an update to the superior DSA in an HOB", async () => {

    });

    it.skip("A modification to a context prefix results in an update to the superior DSA in an HOB", async () => {

    });

    it.skip("A modification to a context prefix's subentry results in an update to the superior DSA in an HOB", async () => {

    });

    it.skip("A deletion of a context prefix's subentries results in an update to the superior DSA in an HOB", async () => {

    });

    it.skip("A deletion of a context prefix results in a termination of the superior HOB", async () => {

    });

    it.skip("An update to an administrative point above an HOB or NHOB will correctly update the subordinate DSA(s)", async () => {

    });

    it.skip("An HOB context prefix update is rejected if the old agreement names a context prefix that cannot be found", async () => {

    });

    it.skip("An HOB context prefix update is rejected if the old agreement names a context prefix that has no superior", async () => {

    });

    it.skip("An HOB context prefix update is rejected if it updates entries from a 'grandfather' naming context that belongs to the subordinate DSA (or these updates are just ignored)", async () => {

    });

    it.skip("An HOB update that attempts to update a 'subr' DSE that is not really a 'subr' will be rejected", async () => {

    });

    it.skip("An HOB that attempts to create a context prefix that contains an alias or subentry will be automatically rejected", async () => {

    });

    it.skip("An HOB that attempts to update a context prefix such that it contains an alias or subentry will be automatically rejected", async () => {

    });

    it.skip("An HOB that attempts to create an agreement that differs from the context prefix info will be automatically rejected", async () => {

    });

    it.skip("An HOB that attempts to modify an agreement such that it differs from the context prefix info will be automatically rejected", async () => {

    });

    it.skip("Operational bindings cannot be created with identifiers that are already in use", async () => {

    });

    it.skip("Operational binding updates that use an operational binding identifier that is not in use are rejected", async () => {

    });

    it.skip("Operational binding updates with a version number that is less than the current version number are rejected automatically", async () => {

    });

    it.skip("Roles cannot be reversed in a modification HOB", async () => {

    });

    it.skip("A nefarious DSA cannot update an operational binding without authenticating as the exact same principal as the one that created the operational binding", async () => {

    });

    it.skip("A nefarious DSA cannot delete an operational binding without authenticating as the exact same principal as the one that created the operational binding", async () => {

    });

    it.skip("Chained read works", async () => {

    });

    it.skip("Chained compare works", async () => {

    });

    it.skip("Chained abandon works", async () => {

    });

    it.skip("Chained list works", async () => {

    });

    it.skip("Chained search works", async () => {

    });

    it.skip("Chained addEntry works", async () => {

    });

    it.skip("Chained removeEntry works", async () => {

    });

    it.skip("Chained modifyEntry works", async () => {

    });

    it.skip("Chained modifyDN works", async () => {

    });

    it.skip("Chained administerPassword works", async () => {

    });

    it.skip("Chained changePassword works", async () => {

    });

    it.skip("Name resolution continues in subordinate DSAs in a HOB", async () => {

    });

    it.skip("Name resolution continues in cross-DSAs in a HOB", async () => {

    });

    it.skip("Name resolution continues in subordinate DSAs in a NHOB", async () => {

    });

    it.skip("Name resolution continues in cross-DSAs in a NHOB", async () => {

    });

    it.skip("ServiceControlOptions.chainingProhibited stops chaining", async () => {

    });

});
